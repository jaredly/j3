
# Now that I have some story

- [x] peggy (text -> CST)
- [x] to-ast (CST -> AST)
	- it would be pretty cool to have these implemented
		with like a query syntax, so "fn literal with an array next to it" would be a thing. idk how to prioritize tho
- [x] fix it so there can be multiple builtin exprs w/ the same name, for fn multi dispatch
- [ ] macro, expansion? and such. type inference comes here as well, to some extent, I believe.
- [ ] java to the script! (AST -> TS)



So, for full constraint solvey madness
we need to be able to express

(this type) is a locally or globally available function,
whose arguments agree with (these potentially blank types)

as well as 

(this type) is the return value for (this type expression)

as like an ... operation?
Is that a type macro? is that how we want to be rollin?
I meeeeean I do like me a good macro.

`(@ret something)` sounds coolio
`(@resolve "+" int 'k)` feels ... um quite dicey?

backing up to remind myself that I can probably be a little simple about this, because of the structured editor bits.



# So

what's the story?

like

there's text in one end, theoretically.
yeah I mean we gotta store it somehow.
be nice to store it in a reasonable way.

ok and also you can like type it out.

So I'm imagining like, the AST happens,
and there's a pass like "try to fill in missing info"
like, resolve references.
and infer types.
ugh do I want to do like a full on datalog or something for the type resolution?
constraint solverrrr
butt datalog won't be able to give me the kinds of errors I want.
Does that mean I implement a datalog?

ok anyway, then we've got like helpful autocompletey things, and helpful autofixy things, etc.

BUT eventually we have to turn it into code.

also there's a type system.

ok, now when I see a :type decorator, I think I'll actually strip it off, and dump it into
a term-level context map, which tells me the types of locals and stuff.
and in there, I can have a flag indicating whether it was autogenerated? OR I could just check to
see if the `loc` is empty? Yeah I mean that sounds fine.

So, how about macro expansion and such? Where does that come in?
Because I think we need to macro-expand before we can do type inference.

ok, so
[entered ast]
-> (macro expand)
[expanded ast]
-> (type inference)
[fully annotated ast]

From there, we can do:
- print stuff back out? (I think I'd want it to never be different? So no need to print?)
- figure out any warnings that need to be reported
- produce javascript or whatever
- come up with autocomplete, probably


umm ok now I'm doubting myself a little bit.
Should I just go ahead and have an AST that is a parsed version of the lisp literals?
eh it seems like there are a lot of advantages.
I'll just want to have annotations that can get me back to the beginning?
hmmmm.

wait
but then, what do you do when you do an operation to the (T)AST?
oh I guess that's when you print it back? maintaining cursor position?
hmmm I guess so.

Ok, and comments? I think we'll only have delimited, inlineable comments.
they'll be nabbed out of the CST, and plopped back in again? Info being "next to X node"


