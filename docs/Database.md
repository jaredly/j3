
# So the Editor Database, looks like

- namespaces is a hashedtree
  - hash -> {child-name => hash}
  - oh and a given hash can be indicated as a root,
    along with a timestamp, right?
    when we import
  - that will take care of root history
- definitions 
  - hash -> term or type

- sandbox(es?)
  - idx -> mnode
  - history n stuffs?


... so ...

names, can be an append-only log
as can definitions

sandbox things are not, however.

hrm maybe leveldb is the right call here? idk.
I don't really need relationality.


How much should I keep in memory?
I can load up the info for a given sandbox.
- but like, the definitions. They don't need to be loaded up,
  right?
  well .. yeah so I guess we would load up the sandbox's
  namespace, right?
  and when autocompleting, we'd load up anything that got shown?
- eh, I mean for now we'll just load everything, of course.

BUT in that case, can I just use localForage?













#### Prev thoughts

- important distinctions -

> erlang nodes have "mnesia" database built in. This is the same concept as javascript web env having 'localStorage', and isn't quite what I mean. But it does go part of the way. This is "the language *runtime* has a bundled database", which is nice. like userdefaults on iOS.
> unison has a database of code, but not data

I'm thikning of a *programming environment* that has a database built into it, such that, when you distribute your program, the database comes along too. Does that make sense? Is it desirable?



# Colocated Database

## Inspiration

- subtext - jonathan edwards video
- eve https://futureofcoding.org/essays/eve/
- I should watch all of these videos https://vimeo.com/user27827062

I should try to use smalltalk in anger.
Also the lion programming language?

## More things


What if there was a database built into the language as well?
One that knew about your types
That you could migrate the types
And you'd get... Like type errors if you wanted to execute something that didn't exist
In dev, you would want to be able to switch between different instantiations of the database, like documents kind of.

So the database would have like tables and rows and stuff, right? Or would it be more of a document store?
And is this where crdts come in?

Schema, 'db/people/get 23
I think the database would just make a bunch of functions available that you could call. And they'd have the types already populated and stuff. 
So (db/people/get 23) would do its deal
Now, if you really want to do this seamlessly, it would be annoying to have to ! everywhere. Although maybe you do what effects to be loud... Yeah maybe it's fine. 

Should I have (something! 12) be the same as !(something 12)? Might be nice. It might make things a little complicated. 


OK SO like, such a database could just be provided by a platform, right?
like it doesn't need to be *built in* built in, it can just be, platform-provided.
and uh the editor-platform definitely provides it.

So, the platform specifies some effects that it'll handle, and like some functions probably?
or maybe the functions get autogenerated for you
like, the editor platform with a database set up for TODOs might look like

```clj
(deftype todo {name string date number sort number})
(def db/todo/get (task [('db/todo/get string (result todo 'NotFound))] todo))
(def db/todo/put (task [('db/todo/update {id string todo $} ())]))
(def db/todo/all (task [('db/todo/all () (array todo))]))
```

So, the story for this is:
- you create a type definotion
- then you go to the database tab, and say "make a table called ${xyz} that stores ${thetype}"
- and then, suddenly these functions are available to you to call, provided by the platform.

But yeah, the nice thing here is that I'm not like hard-wiring anything into the language, or runtime.
It's provided by the platform.

So there's an underlying layer, that would be doing the data synchronizing and such.

I do need to figure out the logistics of platforms though.

Like, in the editor: I'm imagining that you'd be able to enable / disable platforms for a given document.
Right?
And having a platform enabled would:
- potentially add terms to the environment for you to use
- potentially add effect handlers
- potentially add like malloc & free? if we ever go there.

Anddd how would this be specified?
```ts
type Platform = {
  id: string,
  // idk if this would actually be a string,
  // e.g. `(def some thing)`,
  // or if it would be a JSON blob
  prelude: string,
  effects: {
    tag: string,
    input: string, // a stringified version of the type? Or a json blob as well
    output: string, // same question
  }[],
}
```

What would it be like ...
to be able to quote things
...
and have it be typed?
like I'm imagining, defining this platform
```clj
(def user-defaults {
  id "user-defaults"
  prelude (quote-module
    (deftype todo {name string date number completed bool})
    ; must define an `effects` type
    (deftype effects [
      ('db/todo/get string (result todo 'NotFound))
      ('db/todo/put {id string todo $} ())
      ('db/todo/list () (array todo))
    ])
  )
})
```
it's getting a little bit recursive, but I think the upshot is:
there's a document that's defining the "user-defauls" plugin config

BUT a more crude version can just construct the module as a string, and then
compile it on an empty ctx.

