{"map":{"0":{"type":"rich-text","contents":[{"id":"40cf89f4-f4a8-4e62-8243-c9f23f1941a6","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Abstract Syntax Tree","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"adfd4648-fe29-4f0c-912c-e56ab5ac38f6","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Once we have our runtime encoding (primitives, functions, and algebraic data types), we need to decide on an Abstract Syntax Tree. Once again we'll keep the list relatively short, with the goal of \"the simplest language that's still nice to use\".","styles":{}}],"children":[]}],"loc":2},"7":{"type":"blank","loc":7},"9":{"loc":9,"type":"list","values":[10,11,14,16]},"10":{"loc":10,"type":"identifier","text":"deftype"},"11":{"loc":11,"type":"list","values":[12,13]},"12":{"loc":12,"type":"identifier","text":"list"},"13":{"loc":13,"type":"identifier","text":"a"},"14":{"loc":14,"type":"list","values":[15]},"15":{"loc":15,"type":"identifier","text":"nil"},"16":{"loc":16,"type":"list","values":[17,18,19]},"17":{"loc":17,"type":"identifier","text":"cons"},"18":{"loc":18,"type":"identifier","text":"a"},"19":{"loc":19,"type":"list","values":[20,21]},"20":{"loc":20,"type":"identifier","text":"list"},"21":{"loc":21,"type":"identifier","text":"a"},"23":{"loc":23,"type":"list","values":[24,25,197,26,198,130,203,29,199,32,200,36,201,40,202,45]},"24":{"loc":24,"type":"identifier","text":"deftype"},"25":{"loc":25,"type":"identifier","text":"expr"},"26":{"loc":26,"type":"list","values":[27,28,170]},"27":{"loc":27,"type":"identifier","text":"eprim"},"28":{"loc":28,"type":"identifier","text":"prim"},"29":{"loc":29,"type":"list","values":[30,31,172]},"30":{"loc":30,"type":"identifier","text":"evar"},"31":{"loc":31,"type":"identifier","text":"string"},"32":{"loc":32,"type":"list","values":[33,223,35,173]},"33":{"loc":33,"type":"identifier","text":"elambda"},"34":{"loc":34,"type":"identifier","text":"list"},"35":{"loc":35,"type":"identifier","text":"expr"},"36":{"loc":36,"type":"list","values":[37,38,213,174]},"37":{"loc":37,"type":"identifier","text":"eapp"},"38":{"loc":38,"type":"identifier","text":"expr"},"39":{"loc":39,"type":"identifier","text":"list"},"40":{"loc":40,"type":"list","values":[41,220,44,175]},"41":{"loc":41,"type":"identifier","text":"elet"},"42":{"loc":42,"type":"identifier","text":","},"43":{"loc":43,"type":"identifier","text":"expr"},"44":{"loc":44,"type":"identifier","text":"expr"},"45":{"loc":45,"type":"list","values":[46,47,48]},"46":{"loc":46,"type":"identifier","text":"ematch"},"47":{"loc":47,"type":"identifier","text":"expr"},"48":{"loc":48,"type":"list","values":[49,50]},"49":{"loc":49,"type":"identifier","text":"list"},"50":{"loc":50,"type":"list","values":[51,52,53]},"51":{"loc":51,"type":"identifier","text":","},"52":{"loc":52,"type":"identifier","text":"pat"},"53":{"loc":53,"type":"identifier","text":"expr"},"55":{"loc":55,"type":"list","values":[56,57,58,61]},"56":{"loc":56,"type":"identifier","text":"deftype"},"57":{"loc":57,"type":"identifier","text":"prim"},"58":{"loc":58,"type":"list","values":[59,60]},"59":{"loc":59,"type":"identifier","text":"pint"},"60":{"loc":60,"type":"identifier","text":"int"},"61":{"loc":61,"type":"list","values":[62,63]},"62":{"loc":62,"type":"identifier","text":"pbool"},"63":{"loc":63,"type":"identifier","text":"bool"},"65":{"loc":65,"type":"list","values":[66,67,204,68,205,70,206,73,207,76,208,79]},"66":{"loc":66,"type":"identifier","text":"deftype"},"67":{"loc":67,"type":"identifier","text":"pat"},"68":{"loc":68,"type":"list","values":[69,189]},"69":{"loc":69,"type":"identifier","text":"pany"},"70":{"loc":70,"type":"list","values":[71,72,190]},"71":{"loc":71,"type":"identifier","text":"pvar"},"72":{"loc":72,"type":"identifier","text":"string"},"73":{"loc":73,"type":"list","values":[74,75,191]},"74":{"loc":74,"type":"identifier","text":"pprim"},"75":{"loc":75,"type":"identifier","text":"prim"},"76":{"loc":76,"type":"list","values":[77,78,192]},"77":{"loc":77,"type":"identifier","text":"pstr"},"78":{"loc":78,"type":"identifier","text":"string"},"79":{"loc":79,"type":"list","values":[80,81,82,193]},"80":{"loc":80,"type":"identifier","text":"pcon"},"81":{"loc":81,"type":"identifier","text":"string"},"82":{"loc":82,"type":"list","values":[83,84]},"83":{"loc":83,"type":"identifier","text":"list"},"84":{"type":"identifier","text":"pat","loc":84},"86":{"loc":86,"type":"list","values":[87,88,185,89,209,92,210,96]},"87":{"loc":87,"type":"identifier","text":"deftype"},"88":{"loc":88,"type":"identifier","text":"type"},"89":{"loc":89,"type":"list","values":[90,91,186]},"90":{"loc":90,"type":"identifier","text":"tvar"},"91":{"loc":91,"type":"identifier","text":"string"},"92":{"loc":92,"type":"list","values":[93,94,95,187]},"93":{"loc":93,"type":"identifier","text":"tapp"},"94":{"loc":94,"type":"identifier","text":"type"},"95":{"loc":95,"type":"identifier","text":"type"},"96":{"loc":96,"type":"list","values":[97,98,188]},"97":{"loc":97,"type":"identifier","text":"tcon"},"98":{"loc":98,"type":"identifier","text":"string"},"100":{"loc":100,"type":"list","values":[101,102,211,103,212,114,118]},"101":{"loc":101,"type":"identifier","text":"deftype"},"102":{"loc":102,"type":"identifier","text":"stmt"},"103":{"loc":103,"type":"list","values":[104,105,106]},"104":{"loc":104,"type":"identifier","text":"sdeftype"},"105":{"loc":105,"type":"identifier","text":"string"},"106":{"loc":106,"type":"list","values":[107,108]},"107":{"loc":107,"type":"identifier","text":"list"},"108":{"loc":108,"type":"list","values":[109,110,111,196]},"109":{"loc":109,"type":"identifier","text":",,"},"110":{"loc":110,"type":"identifier","text":"string"},"111":{"loc":111,"type":"list","values":[112,113]},"112":{"loc":112,"type":"identifier","text":"list"},"113":{"loc":113,"type":"identifier","text":"type"},"114":{"loc":114,"type":"list","values":[115,116,117]},"115":{"loc":115,"type":"identifier","text":"sdef"},"116":{"loc":116,"type":"identifier","text":"string"},"117":{"loc":117,"type":"identifier","text":"expr"},"118":{"loc":118,"type":"list","values":[119,120]},"119":{"loc":119,"type":"identifier","text":"sexpr"},"120":{"loc":120,"type":"identifier","text":"expr"},"126":{"type":"list","values":[121],"loc":126},"127":{"type":"blank","loc":127},"128":{"type":"rich-text","contents":[{"id":"66469e9b-14f2-47ae-8c19-d25bf193b6f9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We're prefixing constructor names (","styles":{}},{"type":"text","text":"p","styles":{"code":true}},{"type":"text","text":" for prim, ","styles":{}},{"type":"text","text":"e","styles":{"code":true}},{"type":"text","text":" for expr) to prevent name conflicts between the types. Once we implement polymorphic (structural) variants in language version 2, we don't need the crutch.","styles":{}}],"children":[]}],"loc":128},"130":{"type":"list","values":[131,132,133,171],"loc":130},"131":{"type":"identifier","text":"estr","loc":131},"132":{"type":"identifier","text":"string","loc":132},"133":{"type":"list","values":[134,135],"loc":133},"134":{"type":"identifier","text":"list","loc":134},"135":{"type":"list","values":[136,140,168,169],"loc":135},"136":{"type":"identifier","text":",","loc":136},"140":{"type":"identifier","text":"expr","loc":140},"141":{"type":"list","values":[143,144,148],"loc":141},"143":{"type":"identifier","text":"deftype","loc":143},"144":{"type":"list","values":[145,146,147],"loc":144},"145":{"type":"identifier","text":",","loc":145},"146":{"type":"identifier","text":"a","loc":146},"147":{"type":"identifier","text":"b","loc":147},"148":{"type":"list","values":[149,150,151],"loc":148},"149":{"type":"identifier","text":",","loc":149},"150":{"type":"identifier","text":"a","loc":150},"151":{"type":"identifier","text":"b","loc":151},"166":{"type":"rich-text","contents":[{"id":"5dbca58a-f412-4c52-bf54-a25b97d1ae98","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Utility Types (list, tuple)","styles":{}}],"children":[]}],"loc":166},"168":{"type":"identifier","text":"string","loc":168},"169":{"type":"identifier","text":"int","loc":169},"170":{"type":"identifier","text":"int","loc":170},"171":{"type":"identifier","text":"int","loc":171},"172":{"type":"identifier","text":"int","loc":172},"173":{"type":"identifier","text":"int","loc":173},"174":{"type":"identifier","text":"int","loc":174},"175":{"type":"identifier","text":"int","loc":175},"185":{"type":"rich-text","contents":[{"id":"63d1f3f5-b79d-41d6-bb31-c900b2c25808","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"One shortcut that lots of type inference papers make is skipping out on a dedicated \"function\" type, and instead representing it with a constructor, generally called ","styles":{}},{"type":"text","text":"->","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"63d96440-35cd-43c2-9d19-c296b9b704eb","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"So the type ","styles":{}},{"type":"text","text":"(fn [int] string)","styles":{"code":true}},{"type":"text","text":" would be represented as ","styles":{}},{"type":"text","text":"(tapp (tapp (tcon \"->\") (tcon \"int\")) (tcon \"string\"))","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"228d7db9-4685-4340-a941-7afbc5a24988","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"tvar","styles":{"code":true}},{"type":"text","text":" represents a type variable, with a name that's autogenerated to be unique.","styles":{}}],"children":[]}],"loc":185},"186":{"type":"identifier","text":"int","loc":186},"187":{"type":"identifier","text":"int","loc":187},"188":{"type":"identifier","text":"int","loc":188},"189":{"type":"identifier","text":"int","loc":189},"190":{"type":"identifier","text":"int","loc":190},"191":{"type":"identifier","text":"int","loc":191},"192":{"type":"identifier","text":"int","loc":192},"193":{"type":"identifier","text":"int","loc":193},"196":{"type":"identifier","text":"int","loc":196},"197":{"type":"rich-text","contents":[{"id":"75ea0e27-8491-4efb-b875-9d2233bc7ed0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"the trailing ","styles":{}},{"type":"text","text":"int","styles":{"code":true}},{"type":"text","text":" on each constructor is a unique id","styles":{}}],"children":[]}],"loc":197},"198":{"type":"rich-text","contents":[{"id":"89460e23-49ae-4caf-bff2-fc9d477df677","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"prefix,","styles":{"code":true}},{"type":"text","text":" ","styles":{}},{"type":"text","text":"template-pairs","styles":{"code":true}},{"type":"text","text":". All strings are template strings in our language :)","styles":{}}],"children":[]},{"id":"028918e5-425e-4d4a-b35f-992292f48576","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"So ","styles":{}},{"type":"text","text":"\"Hello ${world}!\"","styles":{"code":true}},{"type":"text","text":" would parse into\n","styles":{}},{"type":"text","text":"(estr \"Hello\" [(, (evar \"world\") \"!\" 1234)])","styles":{"code":true}}],"children":[]}],"loc":198},"199":{"type":"rich-text","contents":[{"id":"a22d06e1-f3b8-4ea5-9495-8008c09cc659","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"args, body","styles":{"code":true}},{"type":"text","text":" , parsed from the form ","styles":{}},{"type":"text","text":"(fn [arg1 arg2] body)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":199},"200":{"type":"rich-text","contents":[{"id":"95bf6267-a00d-4526-9030-a36a7626bc44","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"target, args","styles":{"code":true}}],"children":[]}],"loc":200},"201":{"type":"rich-text","contents":[{"id":"03be29ee-aeb9-4157-948a-b659a7695f1e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"bindings, body","styles":{"code":true}}],"children":[]}],"loc":201},"202":{"type":"rich-text","contents":[{"id":"49a25799-d29e-4727-bdd7-a7f1aa12c8f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"target, cases","styles":{"code":true}}],"children":[]}],"loc":202},"203":{"type":"rich-text","contents":[{"id":"17ad6efe-42d4-4d27-9c51-3c5d78e9c338","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"a variable reference! might be local or global","styles":{}}],"children":[]}],"loc":203},"204":{"type":"rich-text","contents":[{"id":"6f27efcf-8281-43df-a7db-3d6bf295483a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"the \"any\" pattern is an underscore ","styles":{}},{"type":"text","text":"_","styles":{"code":true}}],"children":[]}],"loc":204},"205":{"type":"rich-text","contents":[{"id":"6ddf2014-5963-4cfc-b6dd-362d7deef5d1","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"this is for binding the value to a name","styles":{}}],"children":[]}],"loc":205},"206":{"type":"rich-text","contents":[{"id":"9cb6fbcc-eb8a-4ad3-9d68-ccad328238b0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"matching a primitive literal","styles":{}}],"children":[]}],"loc":206},"207":{"type":"rich-text","contents":[{"id":"2e9e6afb-305e-4a1e-bffc-d1c91c86abb5","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"strings in pattern-matching don't support templates ","styles":{}},{"type":"text","text":"${}","styles":{"code":true}},{"type":"text","text":" at the moment, but it could be cool to support that at some point. ","styles":{}},{"type":"text","text":"\"Hello ${name}\"","styles":{"code":true}},{"type":"text","text":" would then match any string with the prefix ","styles":{}},{"type":"text","text":"\"Hello \"","styles":{"code":true}},{"type":"text","text":", and bind the rest to the name ","styles":{}},{"type":"text","text":"name","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":207},"208":{"type":"rich-text","contents":[{"id":"5d650dbb-4ea3-4218-b512-05f2f6d4ab05","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"this is how we match algebraic data types.","styles":{}}],"children":[]},{"id":"bfcd1ea9-b6b8-4fb0-a54e-02f1bb11b99e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"constructor-name, args","styles":{"code":true}}],"children":[]},{"id":"37ee105d-9e86-46b8-9e95-ff1d3f7c236f","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"for example, ","styles":{}},{"type":"text","text":"\",\" [(pvar \"a\") (pvar \"b\")]","styles":{"code":true}},{"type":"text","text":" for the pattern ","styles":{}},{"type":"text","text":"(, a b)","styles":{"code":true}}],"children":[]}],"loc":208},"209":{"type":"rich-text","contents":[{"id":"2feedf64-0153-4e74-8e8b-6087d3c080d5","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"target, arg","styles":{"code":true}},{"type":"text","text":", like the type ","styles":{}},{"type":"text","text":"(list int)","styles":{"code":true}}],"children":[]}],"loc":209},"210":{"type":"rich-text","contents":[{"id":"58665dff-4099-4696-b781-4d35e3ed0fca","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"int","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"list","styles":{"code":true}},{"type":"text","text":", etc.","styles":{}}],"children":[]}],"loc":210},"211":{"type":"rich-text","contents":[{"id":"df607a30-5828-4260-980d-32c88944b664","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Defining custom types! We have the name of the type, and then a list of constructors, each with a name and a list of arguments.","styles":{}}],"children":[]}],"loc":211},"212":{"type":"rich-text","contents":[{"id":"5b1cb78e-1db8-4917-9283-ff672078e56e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"e.g. ","styles":{}},{"type":"text","text":"(def x 2)","styles":{"code":true}},{"type":"text","text":". ","styles":{}},{"type":"text","text":"(defn x [a] b)","styles":{"code":true}},{"type":"text","text":" gets parsed as ","styles":{}},{"type":"text","text":"(def x (fn [x] b))","styles":{"code":true}}],"children":[]}],"loc":212},"213":{"type":"list","values":[39,214],"loc":213},"214":{"type":"identifier","text":"expr","loc":214},"218":{"type":"list","values":[42,219,43],"loc":218},"219":{"type":"identifier","text":"pat","loc":219},"220":{"type":"list","values":[221,218],"loc":220},"221":{"type":"identifier","text":"list","loc":221},"223":{"type":"list","values":[34,224],"loc":223},"224":{"type":"identifier","text":"pat","loc":224},"225":{"type":"rich-text","contents":[{"id":"8701a3f3-c63e-409a-8aeb-d5f9f67d6d6d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The tuple constructor ","styles":{}},{"type":"text","text":",","styles":{"code":true}},{"type":"text","text":" to allow tuples of any length; ","styles":{}},{"type":"text","text":"(, a b c)","styles":{"code":true}},{"type":"text","text":" will be sugar for ","styles":{}},{"type":"text","text":"(, a (, b c))","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"(, a b c d)","styles":{"code":true}},{"type":"text","text":" will desugar to ","styles":{}},{"type":"text","text":"(, a (, b (, c d)))","styles":{"code":true}},{"type":"text","text":" and so on. This will show up when parsing ","styles":{}},{"type":"text","text":"types","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"patterns","styles":{"code":true}},{"type":"text","text":", and ","styles":{}},{"type":"text","text":"expressions","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"c085492e-3818-454b-b9f8-01517a14c7e2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This is really handy for when you want to have a couple things grouped together, but don't want to go to the trouble of coming up with a name for a ","styles":{}},{"type":"text","text":"deftype","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":225},"227":{"type":"rich-text","contents":[{"id":"75a82eab-27f4-4a6a-a060-0a6422d61269","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Sugar","styles":{}}],"children":[]}],"loc":227},"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"44599cf6-4ad3-4aa6-8dbc-61a157d8bf9c","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `r","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1931,"ts":1715028486.133,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `r","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `re","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1932,"ts":1715028486.176,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `re","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `ret","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1933,"ts":1715028486.356,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `ret","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `retu","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1934,"ts":1715028486.405,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `retu","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `retur","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1935,"ts":1715028486.481,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `retur","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `return","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1936,"ts":1715028486.556,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced `return","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1937,"ts":1715028486.709,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1938,"ts":1715028486.873,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" o","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1939,"ts":1715028487.026,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" o","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1940,"ts":1715028487.072,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1941,"ts":1715028487.155,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1942,"ts":1715028487.274,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `p","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1943,"ts":1715028487.448,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `p","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `pu","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1944,"ts":1715028487.623,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `pu","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `pur","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1945,"ts":1715028487.688,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `pur","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `pure","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1946,"ts":1715028487.731,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or `pure","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1947,"ts":1715028487.924,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":";","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1948,"ts":1715028489.383,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":";","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1949,"ts":1715028489.497,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; f","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1950,"ts":1715028490.293,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; f","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; fo","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1951,"ts":1715028490.381,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; fo","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1952,"ts":1715028490.449,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1953,"ts":1715028490.522,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1954,"ts":1715028490.635,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1955,"ts":1715028490.743,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for thi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1956,"ts":1715028490.766,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for thi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for this","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1957,"ts":1715028490.823,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for this","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for this ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1958,"ts":1715028490.965,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for this ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for this","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1959,"ts":1715028492.878,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for this","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for thi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1960,"ts":1715028493.008,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for thi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1961,"ts":1715028493.147,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1962,"ts":1715028493.257,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1963,"ts":1715028493.406,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1964,"ts":1715028493.575,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `r","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1965,"ts":1715028493.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `r","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `re","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1966,"ts":1715028493.905,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `re","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `res","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1967,"ts":1715028493.955,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `res","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `resu","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1968,"ts":1715028494.041,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `resu","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `resul","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1969,"ts":1715028494.091,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `resul","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `result","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1970,"ts":1715028494.129,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `result","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `results","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1971,"ts":1715028494.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for `results","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1972,"ts":1715028494.412,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":",","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1973,"ts":1715028494.509,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":",","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1974,"ts":1715028494.626,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1975,"ts":1715028495.918,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1976,"ts":1715028495.997,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1977,"ts":1715028496.093,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1978,"ts":1715028496.336,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1979,"ts":1715028496.413,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1980,"ts":1715028496.497,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1981,"ts":1715028499.858,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tr","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1982,"ts":1715028499.904,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tr","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1983,"ts":1715028500.004,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is triv","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1984,"ts":1715028500.197,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is triv","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1985,"ts":1715028500.31,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivia","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1986,"ts":1715028500.548,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivia","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1987,"ts":1715028500.639,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1988,"ts":1715028500.763,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1989,"ts":1715028500.907,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1990,"ts":1715028501.167,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(d","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1991,"ts":1715028501.373,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(d","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(de","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1992,"ts":1715028501.401,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(de","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1993,"ts":1715028501.493,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1994,"ts":1715028501.623,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1995,"ts":1715028502.398,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1996,"ts":1715028502.549,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1997,"ts":1715028502.668,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- o","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1998,"ts":1715028502.972,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- o","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":1999,"ts":1715028503.03,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok)","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2000,"ts":1715028503.2,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok)","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2001,"ts":1715028503.451,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":";","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2002,"ts":1715028505.963,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":";","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2003,"ts":1715028507.086,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2004,"ts":1715028507.334,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- o","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2005,"ts":1715028507.367,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- o","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2006,"ts":1715028507.401,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <-","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2007,"ts":1715028507.434,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <-","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2008,"ts":1715028507.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def ","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2009,"ts":1715028507.502,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def ","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2010,"ts":1715028507.536,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(de","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2011,"ts":1715028507.569,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(de","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(d","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2012,"ts":1715028507.602,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(d","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2013,"ts":1715028507.636,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2014,"ts":1715028507.669,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2015,"ts":1715028507.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivia","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2016,"ts":1715028507.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivia","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2017,"ts":1715028507.769,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is triv","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2018,"ts":1715028508.062,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is triv","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2019,"ts":1715028508.312,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; ifor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2020,"ts":1715028510.298,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; ifor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; itfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2021,"ts":1715028510.419,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; itfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2022,"ts":1715028510.501,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it ifor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2023,"ts":1715028510.585,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it ifor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it isfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2024,"ts":1715028510.66,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it isfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2025,"ts":1715028510.746,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is tfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2026,"ts":1715028510.822,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is tfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is thfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2027,"ts":1715028510.896,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is thfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is thefor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2028,"ts":1715028510.99,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is thefor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2029,"ts":1715028511.053,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the ffor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2030,"ts":1715028514.272,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the ffor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the fufor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2031,"ts":1715028514.347,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the fufor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the funfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2032,"ts":1715028514.388,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the funfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the funcfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2033,"ts":1715028514.46,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the funcfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2034,"ts":1715028514.586,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functifor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2035,"ts":1715028514.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functifor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functiofor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2036,"ts":1715028514.693,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functiofor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functionfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2037,"ts":1715028514.776,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the functionfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2038,"ts":1715028514.828,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function tfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2039,"ts":1715028514.888,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function tfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function thfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2040,"ts":1715028514.994,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function thfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function thafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2041,"ts":1715028515.031,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function thafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function thatfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2042,"ts":1715028515.092,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function thatfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2043,"ts":1715028515.178,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that cfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2044,"ts":1715028515.426,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that cfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that cofor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2045,"ts":1715028515.514,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that cofor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that confor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2046,"ts":1715028515.553,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that confor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that consfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2047,"ts":1715028515.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that consfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2048,"ts":1715028515.643,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constrfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2049,"ts":1715028515.693,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constrfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that construfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2050,"ts":1715028515.786,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that construfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that construcfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2051,"ts":1715028515.87,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that construcfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2052,"ts":1715028515.977,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructsfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2053,"ts":1715028516.136,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructsfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2054,"ts":1715028516.22,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs tfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2055,"ts":1715028516.293,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs tfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs thfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2056,"ts":1715028516.411,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs thfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs thefor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2057,"ts":1715028516.447,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs thefor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2058,"ts":1715028516.526,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2059,"ts":1715028517.84,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"hfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2060,"ts":1715028518.029,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"hfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"hafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2061,"ts":1715028518.079,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"hafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"hapfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2062,"ts":1715028518.234,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"hapfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2063,"ts":1715028518.337,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happyfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2064,"ts":1715028518.429,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happyfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2065,"ts":1715028518.556,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy hfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2066,"ts":1715028518.668,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy hfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy hafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2067,"ts":1715028518.778,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy hafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy hfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2068,"ts":1715028519.396,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy hfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2069,"ts":1715028519.532,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy pfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2070,"ts":1715028519.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy pfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy pafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2071,"ts":1715028519.819,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy pafor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy patfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2072,"ts":1715028519.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy patfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy pathfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2073,"ts":1715028519.927,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy pathfor ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\"for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2074,"ts":1715028520.143,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\"for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\".for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2075,"ts":1715028520.488,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\".for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2076,"ts":1715028520.685,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". for ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2077,"ts":1715028521.343,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is tri","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is triv","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2078,"ts":1715028522.363,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is triv","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2079,"ts":1715028522.429,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivia","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2080,"ts":1715028522.53,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivia","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2081,"ts":1715028522.619,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2082,"ts":1715028523.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2083,"ts":1715028523.482,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2084,"ts":1715028523.695,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(d","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2085,"ts":1715028523.836,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(d","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(de","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2086,"ts":1715028523.879,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(de","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2087,"ts":1715028523.935,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2088,"ts":1715028524.105,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2089,"ts":1715028524.329,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2090,"ts":1715028524.454,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2091,"ts":1715028524.561,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- o","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2092,"ts":1715028524.808,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- o","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2093,"ts":1715028524.854,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok)","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2094,"ts":1715028525.019,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial `(def <- ok)","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2095,"ts":1715028525.205,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2096,"ts":1715028527.28,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2097,"ts":1715028527.387,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2098,"ts":1715028531.281,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2099,"ts":1715028542.641,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or  ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2100,"ts":1715028543.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or  ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or s ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2101,"ts":1715028543.682,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or s ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or so ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2102,"ts":1715028543.808,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or so ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or som ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2103,"ts":1715028543.856,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or som ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or some ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2104,"ts":1715028543.918,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or some ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or somet ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2105,"ts":1715028544.015,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or somet ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or someti ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2106,"ts":1715028544.397,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or someti ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometim ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2107,"ts":1715028544.432,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometim ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometime ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2108,"ts":1715028544.515,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometime ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2109,"ts":1715028544.631,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2110,"ts":1715028545.703,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":"; it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":";) it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2111,"ts":1715028548.233,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":";) it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":";); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2112,"ts":1715028548.717,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":";); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2113,"ts":1715028550.234,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"05c042f4-c078-4b85-8344-c022e909d9f3"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure)","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2114,"ts":1715028550.35,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        age  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        a  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2115,"ts":1715028667.065,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        a  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        ad  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2116,"ts":1715028667.278,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        ad  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        add  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2117,"ts":1715028667.39,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        add  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        addr  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2118,"ts":1715028667.563,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        addr  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        addre  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2119,"ts":1715028667.615,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        addre  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        addres  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2120,"ts":1715028667.809,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        addres  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2121,"ts":1715028667.913,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name  (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2122,"ts":1715028669.507,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name  (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name   (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2123,"ts":1715028669.656,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name   (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name    (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2124,"ts":1715028669.779,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name    (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2125,"ts":1715028670.325,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-age data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-a data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2126,"ts":1715028671.925,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-a data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-as data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2127,"ts":1715028672.582,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-as data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-a data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2128,"ts":1715028673.087,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-a data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-ad data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2129,"ts":1715028673.186,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-ad data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-add data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2130,"ts":1715028673.304,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-add data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-addr data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2131,"ts":1715028673.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-addr data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-addre data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2132,"ts":1715028673.516,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-addre data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-addres data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2133,"ts":1715028673.729,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-addres data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2134,"ts":1715028673.82,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you are ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you l ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2135,"ts":1715028678.603,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you l ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you li ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2136,"ts":1715028678.662,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you li ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you liv ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2137,"ts":1715028678.71,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you liv ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2138,"ts":1715028678.766,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live  ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2139,"ts":1715028678.943,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live  ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live a ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2140,"ts":1715028679.026,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live a ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2141,"ts":1715028679.119,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${age} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${a} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2142,"ts":1715028680.154,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${a} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${ad} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2143,"ts":1715028680.396,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${ad} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${add} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2144,"ts":1715028680.511,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${add} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${addr} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2145,"ts":1715028680.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${addr} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${addre} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2146,"ts":1715028680.651,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${addre} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${addres} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2147,"ts":1715028680.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${addres} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2148,"ts":1715028680.97,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address} years old\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2149,"ts":1715028681.984,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2150,"ts":1715028682.477,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2151,"ts":1715028761.197,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". I","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2152,"ts":1715028761.426,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". I","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2153,"ts":1715028761.543,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2154,"ts":1715028761.629,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If y","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2155,"ts":1715028761.744,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If y","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If yo","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2156,"ts":1715028761.868,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If yo","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2157,"ts":1715028762.002,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2158,"ts":1715028762.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you w","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2159,"ts":1715028764.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you w","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you wa","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2160,"ts":1715028764.106,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you wa","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you wan","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2161,"ts":1715028764.249,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you wan","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2162,"ts":1715028764.327,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2163,"ts":1715028764.414,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2164,"ts":1715028764.482,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2165,"ts":1715028764.575,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2166,"ts":1715028764.667,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to h","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2167,"ts":1715028765.681,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to h","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to ha","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2168,"ts":1715028765.774,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to ha","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to hav","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2169,"ts":1715028765.983,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to hav","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2170,"ts":1715028766.038,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2171,"ts":1715028766.859,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2172,"ts":1715028767.419,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2173,"ts":1715028768.175,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a v","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2174,"ts":1715028768.533,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a v","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a va","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2175,"ts":1715028768.691,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a va","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a val","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2176,"ts":1715028768.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a val","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a valu","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2177,"ts":1715028768.849,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a valu","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2178,"ts":1715028768.939,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2179,"ts":1715028769.058,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value b","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2180,"ts":1715028769.696,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value b","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bo","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2181,"ts":1715028769.782,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bo","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bou","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2182,"ts":1715028769.83,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bou","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value boun","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2183,"ts":1715028770.005,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value boun","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2184,"ts":1715028770.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2185,"ts":1715028770.417,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2186,"ts":1715028770.496,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2187,"ts":1715028770.555,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2188,"ts":1715028770.591,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2189,"ts":1715028770.743,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2190,"ts":1715028770.839,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2191,"ts":1715028770.999,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `l","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2192,"ts":1715028771.118,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `l","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `le","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2193,"ts":1715028771.274,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `le","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `let","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2194,"ts":1715028771.33,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `let","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `let-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2195,"ts":1715028771.429,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `let-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `let->","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2196,"ts":1715028771.627,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a `let->","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2197,"ts":1715028772.176,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2198,"ts":1715028772.492,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2199,"ts":1715028772.719,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2200,"ts":1715028772.833,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" tha","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2201,"ts":1715028772.88,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" tha","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2202,"ts":1715028772.956,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2203,"ts":1715028773.026,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2204,"ts":1715028773.431,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2205,"ts":1715028773.627,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *is","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2206,"ts":1715028773.708,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *is","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *isn","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2207,"ts":1715028773.768,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *isn","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *isn'","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2208,"ts":1715028773.833,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *isn'","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *isn't","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2209,"ts":1715028773.901,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that *isn't","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2210,"ts":1715028774.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2211,"ts":1715028774.431,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2212,"ts":1715028774.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" al","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2213,"ts":1715028774.665,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" al","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alr","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2214,"ts":1715028774.755,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alr","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alre","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2215,"ts":1715028774.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alre","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alrea","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2216,"ts":1715028774.864,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alrea","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alread","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2217,"ts":1715028774.924,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" alread","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2218,"ts":1715028774.989,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2219,"ts":1715028775.131,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already w","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2220,"ts":1715028775.35,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already w","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wr","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2221,"ts":1715028775.389,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wr","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wra","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2222,"ts":1715028775.485,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wra","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrap","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2223,"ts":1715028775.514,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrap","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapp","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2224,"ts":1715028775.598,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapp","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrappe","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2225,"ts":1715028775.832,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrappe","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2226,"ts":1715028775.977,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2227,"ts":1715028776.077,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2228,"ts":1715028776.149,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2229,"ts":1715028776.188,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2230,"ts":1715028776.23,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2231,"ts":1715028776.351,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2232,"ts":1715028776.465,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a r","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2233,"ts":1715028776.659,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a r","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a re","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2234,"ts":1715028776.692,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a re","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a res","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2235,"ts":1715028776.747,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a res","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a resu","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2236,"ts":1715028776.859,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a resu","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a resul","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2237,"ts":1715028776.923,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a resul","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2238,"ts":1715028776.983,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result,","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2239,"ts":1715028777.134,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result,","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2240,"ts":1715028777.231,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, y","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2241,"ts":1715028777.366,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, y","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, yo","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2242,"ts":1715028777.474,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, yo","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2243,"ts":1715028777.573,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2244,"ts":1715028777.609,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you u","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2245,"ts":1715028777.783,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you u","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you us","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2246,"ts":1715028777.875,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you us","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2247,"ts":1715028777.931,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2248,"ts":1715028778.013,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2249,"ts":1715028778.166,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use `<","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2250,"ts":1715028778.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use `<","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use `<-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2251,"ts":1715028778.699,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use `<-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2252,"ts":1715028778.97,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2253,"ts":1715028779.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2254,"ts":1715028779.418,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2255,"ts":1715028779.506,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" the","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2256,"ts":1715028779.58,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" the","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" ther","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2257,"ts":1715028779.606,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" ther","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2258,"ts":1715028779.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2259,"ts":1715028779.764,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2260,"ts":1715028779.839,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there to","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2261,"ts":1715028779.913,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there to","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2262,"ts":1715028780.031,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too.","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2263,"ts":1715028780.218,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too.","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2264,"ts":1715028780.339,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. F","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2265,"ts":1715028781.333,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. F","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. Fo","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2266,"ts":1715028781.497,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. Fo","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2267,"ts":1715028781.581,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2268,"ts":1715028781.698,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For e","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2269,"ts":1715028781.801,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For e","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For ex","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2270,"ts":1715028781.978,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For ex","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For exa","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2271,"ts":1715028782.123,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For exa","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For exam","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2272,"ts":1715028782.405,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For exam","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For examp","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2273,"ts":1715028782.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For examp","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For exampl","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2274,"ts":1715028782.643,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For exampl","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2275,"ts":1715028782.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2276,"ts":1715028782.775,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2277,"ts":1715028782.956,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2278,"ts":1715028783.252,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(l","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2279,"ts":1715028783.476,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(l","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(le","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2280,"ts":1715028783.569,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(le","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2281,"ts":1715028783.616,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2282,"ts":1715028783.724,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let->","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2283,"ts":1715028783.941,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let->","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2284,"ts":1715028784.049,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2285,"ts":1715028784.202,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2286,"ts":1715028786.01,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [ag","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2287,"ts":1715028786.159,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [ag","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2288,"ts":1715028786.199,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2289,"ts":1715028786.264,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2290,"ts":1715028786.419,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2291,"ts":1715028786.62,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2292,"ts":1715028786.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,- ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2293,"ts":1715028786.909,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,- ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2294,"ts":1715028787.159,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2295,"ts":1715028787.268,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (,","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2296,"ts":1715028787.391,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2297,"ts":1715028787.571,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2298,"ts":1715028787.725,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2299,"ts":1715028787.848,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 1","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2300,"ts":1715028787.985,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 1","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2301,"ts":1715028788.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2302,"ts":1715028789.189,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)]","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2303,"ts":1715028789.591,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)]","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2304,"ts":1715028791.818,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2305,"ts":1715028791.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ag","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2306,"ts":1715028792.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ag","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] age","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2307,"ts":1715028792.167,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] age","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ag","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2308,"ts":1715028793.467,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ag","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2309,"ts":1715028793.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2310,"ts":1715028793.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] .","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2311,"ts":1715028795.749,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] .","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ..","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2312,"ts":1715028795.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ..","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ...","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2313,"ts":1715028796.497,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ...","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ...)","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2314,"ts":1715028797.064,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example `(let-> [age (<- 10)] ...)","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2315,"ts":1715028797.301,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2316,"ts":1715028798.719,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2317,"ts":1715028800.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" is","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2318,"ts":1715028800.926,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" is","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" is ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2319,"ts":1715028801.02,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" is ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" is","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2320,"ts":1715028803.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" is","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2321,"ts":1715028803.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2322,"ts":1715028804.424,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" .","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2323,"ts":1715028804.639,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":" .","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2324,"ts":1715028805.203,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2325,"ts":1715028805.682,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". I","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2326,"ts":1715028809.897,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". I","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2327,"ts":1715028810.113,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2328,"ts":1715028810.386,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2329,"ts":1715028810.435,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2330,"ts":1715028810.512,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In thi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2331,"ts":1715028810.568,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In thi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2332,"ts":1715028810.626,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2333,"ts":1715028810.703,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this s","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2334,"ts":1715028810.853,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this s","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this si","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2335,"ts":1715028810.905,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this si","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this si,","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2336,"ts":1715028811.105,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this si,","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this si","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2337,"ts":1715028811.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this si","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this sim","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2338,"ts":1715028811.651,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this sim","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simp","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2339,"ts":1715028811.81,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simp","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simpl","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2340,"ts":1715028811.868,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simpl","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2341,"ts":1715028811.971,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2342,"ts":1715028812.069,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple e","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2343,"ts":1715028812.221,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple e","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple ex","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2344,"ts":1715028812.388,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple ex","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple exa","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2345,"ts":1715028812.494,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple exa","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple exam","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2346,"ts":1715028812.577,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple exam","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple examp","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2347,"ts":1715028812.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple examp","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple exampl","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2348,"ts":1715028812.768,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple exampl","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2349,"ts":1715028812.851,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example,","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2350,"ts":1715028812.938,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example,","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2351,"ts":1715028813.288,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2352,"ts":1715028814.881,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2353,"ts":1715028814.956,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, tha","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2354,"ts":1715028815.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, tha","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2355,"ts":1715028815.076,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2356,"ts":1715028815.165,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2357,"ts":1715028815.354,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `l","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2358,"ts":1715028815.591,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `l","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `le","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2359,"ts":1715028815.704,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `le","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `let","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2360,"ts":1715028815.752,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `let","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `let-","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2361,"ts":1715028815.815,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `let-","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `let->","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2362,"ts":1715028816.019,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that `let->","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2363,"ts":1715028816.457,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2364,"ts":1715028816.627,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2365,"ts":1715028816.846,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" is","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2366,"ts":1715028816.935,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" is","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2367,"ts":1715028817.013,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn'","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2368,"ts":1715028817.081,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn'","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2369,"ts":1715028817.153,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2370,"ts":1715028817.246,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't n","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2371,"ts":1715028817.855,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't n","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't ne","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2372,"ts":1715028817.918,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't ne","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't nee","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2373,"ts":1715028818.034,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't nee","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't need","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2374,"ts":1715028818.195,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't need","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't neede","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2375,"ts":1715028818.36,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't neede","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2376,"ts":1715028818.522,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed,","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2377,"ts":1715028819.07,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed,","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2378,"ts":1715028819.151,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2379,"ts":1715028819.804,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, th","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2380,"ts":1715028819.871,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, th","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2381,"ts":1715028819.964,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2382,"ts":1715028820.055,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2383,"ts":1715028820.189,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the ab","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2384,"ts":1715028820.614,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the ab","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the abo","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2385,"ts":1715028820.743,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the abo","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the abov","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2386,"ts":1715028820.862,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the abov","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2387,"ts":1715028820.901,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2388,"ts":1715028821.08,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above i","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2389,"ts":1715028821.248,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above i","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2390,"ts":1715028821.327,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2391,"ts":1715028821.403,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is e","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2392,"ts":1715028822.072,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is e","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is eq","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2393,"ts":1715028822.322,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is eq","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2394,"ts":1715028822.377,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equi","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2395,"ts":1715028822.439,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equi","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equiv","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2396,"ts":1715028822.78,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equiv","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equiva","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2397,"ts":1715028822.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equiva","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equival","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2398,"ts":1715028823.18,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equival","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivale","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2399,"ts":1715028823.306,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivale","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalen","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2400,"ts":1715028823.369,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalen","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2401,"ts":1715028823.473,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2402,"ts":1715028823.637,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent t","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2403,"ts":1715028823.68,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent t","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2404,"ts":1715028823.772,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2405,"ts":1715028823.844,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2406,"ts":1715028824.138,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2407,"ts":1715028826.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(l","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2408,"ts":1715028826.314,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(l","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(le","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2409,"ts":1715028826.362,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(le","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2410,"ts":1715028826.418,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2411,"ts":1715028826.511,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2412,"ts":1715028827.015,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [a","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2413,"ts":1715028827.131,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [a","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [ag","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2414,"ts":1715028827.262,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [ag","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2415,"ts":1715028827.305,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2416,"ts":1715028827.397,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 1","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2417,"ts":1715028827.608,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 1","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2418,"ts":1715028827.682,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10]","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2419,"ts":1715028827.916,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10]","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10].","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2420,"ts":1715028828.381,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10].","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10]","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2421,"ts":1715028828.688,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10]","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2422,"ts":1715028828.772,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] .","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2423,"ts":1715028828.926,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] .","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ..","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2424,"ts":1715028829.053,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ..","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ...","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2425,"ts":1715028829.19,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ...","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ...)","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2426,"ts":1715028829.556,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to `(let [age 10] ...)","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2427,"ts":1715028829.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2428,"ts":1715028830.343,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":". If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2429,"ts":1715028842.524,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"prev":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"meta":{},"metaPrev":{},"map":{"233":{"type":"rich-text","contents":[{"id":"80abb40a-5a43-4df0-97d8-15ffa5439f3a","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"We've also got a simplified \"do notation\" to allow for \"state\" and \"error handling\" in a pure & functional language.\n","styles":{}},{"type":"text","text":"(let-> [pat init] value)","styles":{"code":true}},{"type":"text","text":" is translated into continuation-passing style with ","styles":{}},{"type":"text","text":">>=","styles":{"code":true}},{"type":"text","text":" (pronounced \"bind\"):\n","styles":{}},{"type":"text","text":"(>>= init (fn [pat] value))","styles":{"code":true}}],"children":[]},{"id":"05c042f4-c078-4b85-8344-c022e909d9f3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"As a small example, consider the result type ","styles":{}},{"type":"text","text":"(deftype (result good bad) (ok good) (err bad))","styles":{"code":true}},{"type":"text","text":", similar to the one seen in Rust. If we define bind to be\n","styles":{}},{"type":"text","text":"(defn >>= [res next]\n  (match res\n    (ok value) (next value)\n    (err e) (err e))","styles":{"code":true}}],"children":[]},{"id":"5f469799-c113-493b-91e5-df7e63d9ead9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Then we can use our \"do notation\" to handle functions that return results, and it will \"bail\" if ever it encounters an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":". Here's an example with some simple parsing:","styles":{}}],"children":[]},{"id":"4eaaa984-1899-4ce2-abb0-d1762d375bc2","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"(let-> [name     (parse-name data)\n        address  (parse-address data)]\n  (<- \"Hello ${name}, you live at ${address}.\"))","styles":{"code":true}}],"children":[]},{"id":"690ec5fb-0d05-472b-9906-bd53b9932c2e","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"parse-name","styles":{"code":true}},{"type":"text","text":" and ","styles":{}},{"type":"text","text":"parse-age","styles":{"code":true}},{"type":"text","text":" both take some input data and return a ","styles":{}},{"type":"text","text":"(result string err-type)","styles":{"code":true}},{"type":"text","text":". If both succeed, then we can proceed with constructing the welcome message, but if either fails the whole expression will evaluate to an ","styles":{}},{"type":"text","text":"err","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"4c134634-1f34-4ef0-b475-855d796bbc25","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"The ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" function in this example is pronounced ","styles":{}},{"type":"text","text":"return","styles":{"code":true}},{"type":"text","text":" (or sometimes ","styles":{}},{"type":"text","text":"pure","styles":{"code":true}},{"type":"text","text":"); it is the function that constructs the \"happy path\". For ","styles":{}},{"type":"text","text":"results","styles":{"code":true}},{"type":"text","text":", it is trivial ","styles":{}},{"type":"text","text":"(def <- ok)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]},{"id":"44599cf6-4ad3-4aa6-8dbc-61a157d8bf9c","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"If you want to have a value bound in a ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" that ","styles":{}},{"type":"text","text":"isn't","styles":{"italic":true}},{"type":"text","text":" already wrapped in a result, you use ","styles":{}},{"type":"text","text":"<-","styles":{"code":true}},{"type":"text","text":" there too. For example ","styles":{}},{"type":"text","text":"(let-> [age (<- 10)] ...)","styles":{"code":true}},{"type":"text","text":". In this simple example, that ","styles":{}},{"type":"text","text":"let->","styles":{"code":true}},{"type":"text","text":" isn't needed, the above is equivalent to ","styles":{}},{"type":"text","text":"(let [age 10] ...)","styles":{"code":true}},{"type":"text","text":".","styles":{}}],"children":[]}],"loc":233}},"nsMap":{},"nsPrev":{},"id":2430,"ts":1715028842.748,"libraryRoot":""}],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":228,"idx":0},{"type":"ns","child":234,"idx":228},{"type":"ns-top","idx":234},{"type":"rich-text","idx":233,"sel":"4c134634-1f34-4ef0-b475-855d796bbc25"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,3,167,228,129,54,22,64,85,99,6],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3},"6":{"type":"normal","id":6,"top":7,"children":[]},"8":{"type":"normal","id":8,"top":9,"children":[],"display":{"id":"none","options":null},"collapsed":false},"22":{"type":"normal","id":22,"top":23,"children":[]},"54":{"type":"normal","id":54,"top":55,"children":[]},"64":{"type":"normal","id":64,"top":65,"children":[]},"85":{"type":"normal","id":85,"top":86,"children":[]},"99":{"type":"normal","id":99,"top":100,"children":[]},"129":{"type":"normal","top":128,"children":[],"id":129},"142":{"type":"normal","top":141,"children":[],"id":142},"167":{"type":"normal","top":166,"children":[8,142],"id":167,"collapsed":false},"226":{"type":"normal","top":225,"children":[],"id":226},"228":{"type":"normal","top":227,"id":228,"children":[226,234]},"234":{"type":"normal","top":233,"children":[],"id":234}},"highlight":[],"evaluator":["bootstrap.js"]}