{"map":{"0":{"type":"rich-text","contents":[{"id":"50e95763-10e4-446e-b3fb-103c8c8a05d0","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Structured Editor","styles":{}}],"children":[]},{"id":"6875ae25-05e4-4f1e-9431-578881fb654f","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"A bit about this editor environment","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"22dcf8b2-852c-4062-a235-3150b52701e9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial takes place in a structured editor, which has some important differences from a standard text editor. The \"structured\" part refers to the fact that the editor's \"source of truth\" representation of your source code is not a long sequence of utf-8 characters, but rather \"structured data\". ","styles":{}}],"children":[]},{"id":"deabf343-b8ef-4f73-a1e8-6af210a44de9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"For many structured editors, the structure of the data is the Abstract Syntax Tree (AST) of the given programming language. Typical programming languages have node types for expressions (variables, numbers, strings, function application, lambdas, array & object literals, infix boolean and prefix unary operators), statements (control structures such as ","styles":{}},{"type":"text","text":"if","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"for","styles":{"code":true}},{"type":"text","text":", and ","styles":{}},{"type":"text","text":"while","styles":{"code":true}},{"type":"text","text":", function and class declaration), and, types (type variables, type application).","styles":{}}],"children":[]},{"id":"4db72981-1cc1-4f35-8e3c-fb37cccbf403","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This has the downside of being quite complicated; both on the implementation side (ensuring that rendering, formatting, and editing each node type works as intended is a huge job) but more importantly: there's a lot of mental overhead for the user, because key strokes might do different things depending on what kind of Node your cursor is in, so you have to be aware of what kind of node (out of dozens of types) you are currently editing.","styles":{}}],"children":[]},{"id":"8e3f048c-0af6-4d0f-a7ed-0ffd4bf406a3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In an attempt to avoid these downsides, this editor works on what I call the \"Concrete Syntax Tree\"; essentially lisp s-expressions (identifiers, strings, lists, and arrays). In my opinion, this strikes a nice balance between the benefits you get from moving beyond \"a jumble of text characters in a file\" while still keeping the representation simple enough that it doesn't get in the way of the editing experience.","styles":{}}],"children":[]},{"id":"982a4c26-848c-48c6-bd61-9eeb08244bf8","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's an example of some syntax in this structured editor:","styles":{}}],"children":[]}],"loc":2},"4":{"type":"list","values":[6,7,9,18],"loc":4},"6":{"type":"identifier","text":"hello","loc":6},"7":{"type":"string","first":8,"templates":[{"expr":16,"suffix":17}],"loc":7},"8":{"type":"stringText","loc":8,"text":"world "},"9":{"type":"identifier","text":"12","loc":9},"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spreaded]\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14},"16":{"type":"identifier","text":"abc","loc":16},"17":{"type":"stringText","text":"!","loc":17},"18":{"type":"array","values":[24],"loc":18},"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example of some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19},"21":{"type":"identifier","text":"b","loc":21},"24":{"type":"spread","contents":21,"loc":24},"25":{"type":"rich-text","contents":[{"id":"ec226016-8866-41eb-93e8-0ec20aaa6ff6","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"The Concrete Syntax Tree","styles":{}}],"children":[]}],"loc":25},"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightly abbreviated to include only the variants that our parser will be concerned with):","styles":{}}],"children":[]}],"loc":27},"29":{"type":"rich-text","contents":[{"id":"bf1f75df-1ab5-4d81-a2a6-f8e1a48af847","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"About the editor","styles":{}}],"children":[]}],"loc":29},"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasant.","styles":{}}],"children":[]}],"loc":31},"33":{"type":"list","values":[35,38,39,97],"loc":33},"35":{"type":"identifier","text":"defn","loc":35},"38":{"type":"identifier","text":"fib","loc":38},"39":{"type":"array","values":[41],"loc":39},"40":{"type":"blank","loc":40},"41":{"type":"identifier","text":"v","loc":41},"42":{"type":"list","values":[90,91,106],"loc":42},"89":{"type":"blank","loc":89},"90":{"type":"identifier","text":"+","loc":90},"91":{"type":"list","values":[92,93],"loc":91},"92":{"type":"identifier","text":"fib","loc":92},"93":{"type":"list","values":[94,95,96],"loc":93},"94":{"type":"identifier","text":"-","loc":94},"95":{"type":"identifier","text":"v","loc":95},"96":{"type":"identifier","text":"1","loc":96},"97":{"type":"list","values":[98,99,118,105,112,42,114],"loc":97},"98":{"type":"identifier","text":"if","loc":98},"99":{"type":"list","values":[102,103,104],"loc":99},"102":{"type":"identifier","text":"<","loc":102},"103":{"type":"identifier","text":"v","loc":103},"104":{"type":"identifier","text":"2","loc":104},"105":{"type":"identifier","text":"1","loc":105},"106":{"type":"list","values":[107,108],"loc":106},"107":{"type":"identifier","text":"fib","loc":107},"108":{"type":"list","values":[109,110,111],"loc":108},"109":{"type":"identifier","text":"-","loc":109},"110":{"type":"identifier","text":"v","loc":110},"111":{"type":"identifier","text":"2","loc":111},"112":{"type":"comment","text":" a plain comment","loc":112},"113":{"type":"list","values":[115,121,119],"loc":113},"114":{"type":"comment-node","loc":114,"contents":113},"115":{"type":"identifier","text":"some","loc":115},"116":{"type":"identifier","text":"commented","loc":116},"117":{"type":"identifier","text":"+","loc":117},"118":{"type":"rich-text","contents":[{"id":"3c40e1ea-fc9c-49fd-9cbe-880f5e3761c5","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"A ","styles":{}},{"type":"text","text":"rich-text","styles":{"italic":true}},{"type":"text","text":" block, which gets treated as a comment.","styles":{}}],"children":[]}],"loc":118},"119":{"type":"list","values":[117,120],"loc":119},"120":{"type":"identifier","text":"code","loc":120},"121":{"type":"array","values":[116,122],"loc":121},"122":{"type":"identifier","text":"out","loc":122},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting,","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1564,"ts":1715361414.064,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting,","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1565,"ts":1715361414.145,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, m","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1566,"ts":1715361414.252,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, m","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, ma","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1567,"ts":1715361414.348,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, ma","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, mak","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1568,"ts":1715361414.447,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, mak","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, make","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1569,"ts":1715361414.543,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, make","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1570,"ts":1715361414.61,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1571,"ts":1715361414.703,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes n","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1572,"ts":1715361414.971,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes n","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1573,"ts":1715361415.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1574,"ts":1715361415.175,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no d","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1575,"ts":1715361415.365,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no d","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no di","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1576,"ts":1715361415.51,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no di","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no dif","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1577,"ts":1715361415.591,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no dif","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no diff","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1578,"ts":1715361415.718,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no diff","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no diffe","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1579,"ts":1715361415.853,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no diffe","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1580,"ts":1715361415.926,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differe","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1581,"ts":1715361416.007,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differe","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differen","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1582,"ts":1715361416.112,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differen","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no different","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1583,"ts":1715361416.186,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no different","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no different ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1584,"ts":1715361416.27,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no different ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no different","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1585,"ts":1715361416.674,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no different","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differen","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1586,"ts":1715361416.778,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differen","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differenc","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1587,"ts":1715361416.853,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no differenc","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1588,"ts":1715361416.889,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1589,"ts":1715361416.986,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1590,"ts":1715361417.051,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1591,"ts":1715361417.086,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1592,"ts":1715361417.649,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1593,"ts":1715361417.738,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to th","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1594,"ts":1715361417.846,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to th","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1595,"ts":1715361417.895,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1596,"ts":1715361417.984,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the c","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1597,"ts":1715361423.142,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the c","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the co","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1598,"ts":1715361423.218,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the co","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the com","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1599,"ts":1715361423.255,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the com","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the comp","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1600,"ts":1715361423.32,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the comp","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1601,"ts":1715361423.419,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compil","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1602,"ts":1715361423.523,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compil","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compile","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1603,"ts":1715361423.612,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compile","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1604,"ts":1715361423.686,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler;","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1605,"ts":1715361424.047,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler;","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1606,"ts":1715361424.151,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1607,"ts":1715361424.206,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; th","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1608,"ts":1715361424.273,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; th","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1609,"ts":1715361424.344,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1610,"ts":1715361424.415,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the f","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1611,"ts":1715361424.518,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the f","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the fi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1612,"ts":1715361424.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the fi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the fir","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1613,"ts":1715361424.704,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the fir","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the firs","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1614,"ts":1715361424.854,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the firs","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1615,"ts":1715361424.932,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1616,"ts":1715361424.991,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first s","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1617,"ts":1715361426.328,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first s","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first st","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1618,"ts":1715361426.385,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first st","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first stp","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1619,"ts":1715361426.501,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first stp","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first stpe","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1620,"ts":1715361426.516,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first stpe","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first stp","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1621,"ts":1715361427.043,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first stp","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first st","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1622,"ts":1715361427.143,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first st","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first ste","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1623,"ts":1715361427.232,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first ste","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1624,"ts":1715361427.32,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1625,"ts":1715361427.412,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step i","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1626,"ts":1715361427.522,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step i","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1627,"ts":1715361427.566,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1628,"ts":1715361427.896,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in e","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1629,"ts":1715361428.079,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in e","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in ev","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1630,"ts":1715361428.239,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in ev","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in eva","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1631,"ts":1715361428.383,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in eva","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in eval","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1632,"ts":1715361428.418,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in eval","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evalu","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1633,"ts":1715361428.52,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evalu","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evalua","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1634,"ts":1715361428.603,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evalua","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluat","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1635,"ts":1715361428.65,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluat","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluati","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1636,"ts":1715361428.72,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluati","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluatio","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1637,"ts":1715361428.752,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluatio","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1638,"ts":1715361428.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1639,"ts":1715361428.9,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation i","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1640,"ts":1715361429.025,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation i","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1641,"ts":1715361429.088,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1642,"ts":1715361429.173,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is a","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1643,"ts":1715361433.39,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is a","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is an","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1644,"ts":1715361433.441,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is an","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is ana","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1645,"ts":1715361433.521,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is ana","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is anal","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1646,"ts":1715361433.545,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is anal","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analy","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1647,"ts":1715361433.643,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analy","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyz","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1648,"ts":1715361433.946,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyz","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1649,"ts":1715361434.059,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1650,"ts":1715361434.101,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1651,"ts":1715361434.174,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1652,"ts":1715361434.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing e","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1653,"ts":1715361434.536,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing e","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing ev","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1654,"ts":1715361434.617,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing ev","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eve","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1655,"ts":1715361434.705,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eve","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1656,"ts":1715361434.844,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1657,"ts":1715361434.851,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrh","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1658,"ts":1715361435.094,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrh","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrht","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1659,"ts":1715361435.097,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrht","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrhti","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1660,"ts":1715361435.153,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrhti","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrhtin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1661,"ts":1715361435.247,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrhtin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrhti","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1662,"ts":1715361435.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrhti","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrht","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1663,"ts":1715361435.89,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrht","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrh","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1664,"ts":1715361435.91,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyrh","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1665,"ts":1715361436.056,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1666,"ts":1715361436.226,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyy","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1667,"ts":1715361436.506,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyy","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1668,"ts":1715361437.067,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eve","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1669,"ts":1715361437.132,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eve","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1670,"ts":1715361437.76,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing evey","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyt","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1671,"ts":1715361437.956,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyt","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyth","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1672,"ts":1715361438.004,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveyth","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveythi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1673,"ts":1715361438.057,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveythi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveythin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1674,"ts":1715361438.136,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveythin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1675,"ts":1715361438.193,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1676,"ts":1715361438.295,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything a","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1677,"ts":1715361438.372,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything a","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything an","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1678,"ts":1715361438.489,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything an","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1679,"ts":1715361438.56,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1680,"ts":1715361438.626,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and a","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1681,"ts":1715361439.677,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and a","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and ar","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1682,"ts":1715361439.838,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and ar","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1683,"ts":1715361439.943,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arra","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1684,"ts":1715361440.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arra","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arran","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1685,"ts":1715361440.401,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arran","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arrang","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1686,"ts":1715361440.51,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arrang","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arrangi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1687,"ts":1715361440.644,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arrangi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arrangin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1688,"ts":1715361440.682,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arrangin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1689,"ts":1715361440.789,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1690,"ts":1715361440.872,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1691,"ts":1715361440.934,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging th","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1692,"ts":1715361440.992,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging th","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging the","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1693,"ts":1715361441.09,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging the","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1694,"ts":1715361441.151,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1695,"ts":1715361441.283,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them i","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1696,"ts":1715361441.355,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them i","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them in","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1697,"ts":1715361441.409,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them in","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them int","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1698,"ts":1715361441.467,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them int","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1699,"ts":1715361441.655,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1700,"ts":1715361441.663,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into d","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1701,"ts":1715361441.81,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into d","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into de","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1702,"ts":1715361441.856,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into de","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dep","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1703,"ts":1715361441.998,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dep","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depe","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1704,"ts":1715361442.084,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depe","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depen","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1705,"ts":1715361442.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depen","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depend","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1706,"ts":1715361442.261,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depend","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depende","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1707,"ts":1715361442.328,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into depende","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependen","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1708,"ts":1715361442.412,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependen","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependenc","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1709,"ts":1715361442.523,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependenc","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1710,"ts":1715361442.612,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1711,"ts":1715361442.72,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency o","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1712,"ts":1715361442.83,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency o","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency or","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1713,"ts":1715361442.91,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency or","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency ord","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1714,"ts":1715361443.065,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency ord","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency orde","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1715,"ts":1715361443.145,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency orde","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1716,"ts":1715361443.196,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1717,"ts":1715361443.304,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1718,"ts":1715361447.029,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. T","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1719,"ts":1715361447.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. T","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. Th","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1720,"ts":1715361447.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. Th","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. Thi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1721,"ts":1715361447.293,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. Thi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1722,"ts":1715361447.341,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1723,"ts":1715361447.428,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1724,"ts":1715361447.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This tw","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1725,"ts":1715361447.674,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This tw","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1726,"ts":1715361447.727,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1727,"ts":1715361447.932,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-l","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1728,"ts":1715361448.164,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-l","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-le","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1729,"ts":1715361448.229,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-le","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-lev","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1730,"ts":1715361448.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-lev","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-leve","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1731,"ts":1715361448.375,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-leve","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1732,"ts":1715361448.438,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1733,"ts":1715361448.542,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level s","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1734,"ts":1715361448.992,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level s","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level st","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1735,"ts":1715361449.06,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level st","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level str","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1736,"ts":1715361449.089,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level str","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level stru","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1737,"ts":1715361449.2,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level stru","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level struc","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1738,"ts":1715361449.279,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level struc","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level struct","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1739,"ts":1715361449.408,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level struct","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structu","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1740,"ts":1715361449.503,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structu","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structur","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1741,"ts":1715361449.54,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structur","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1742,"ts":1715361449.625,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1743,"ts":1715361449.892,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure l","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1744,"ts":1715361450.011,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure l","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure le","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1745,"ts":1715361450.078,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure le","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure lea","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1746,"ts":1715361450.154,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure lea","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure lead","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1747,"ts":1715361450.391,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure lead","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1748,"ts":1715361450.459,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1749,"ts":1715361450.604,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1750,"ts":1715361450.782,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1751,"ts":1715361450.87,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1752,"ts":1715361450.913,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1753,"ts":1715361451.057,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1754,"ts":1715361451.161,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1755,"ts":1715361451.7,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"l","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1756,"ts":1715361451.861,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"l","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"li","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1757,"ts":1715361451.921,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"li","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"lit","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1758,"ts":1715361452.018,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"lit","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"lite","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1759,"ts":1715361452.15,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"lite","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"liter","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1760,"ts":1715361452.185,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"liter","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"litera","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1761,"ts":1715361452.312,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"litera","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literat","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1762,"ts":1715361452.811,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literat","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1763,"ts":1715361452.885,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1764,"ts":1715361452.968,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate p","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1765,"ts":1715361453.069,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate p","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate pr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1766,"ts":1715361453.155,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate pr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate pro","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1767,"ts":1715361453.209,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate pro","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate prog","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1768,"ts":1715361453.31,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate prog","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate progr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1769,"ts":1715361453.364,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate progr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate progra","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1770,"ts":1715361453.504,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate progra","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate program","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1771,"ts":1715361453.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate program","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programm","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1772,"ts":1715361453.712,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programm","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programmi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1773,"ts":1715361453.814,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programmi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programmin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1774,"ts":1715361453.875,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programmin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1775,"ts":1715361453.919,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\"","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1776,"ts":1715361454.173,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\"","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1777,"ts":1715361454.285,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" e","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1778,"ts":1715361454.377,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" e","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" ex","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1779,"ts":1715361454.533,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" ex","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exp","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1780,"ts":1715361454.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exp","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1781,"ts":1715361454.743,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expre","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1782,"ts":1715361454.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expre","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exprei","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1783,"ts":1715361454.897,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exprei","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expreie","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1784,"ts":1715361455.06,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expreie","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exprei","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1785,"ts":1715361455.365,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exprei","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expre","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1786,"ts":1715361455.486,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expre","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expr","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1787,"ts":1715361455.6,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expr","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exp","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1788,"ts":1715361455.729,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exp","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expe","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1789,"ts":1715361455.776,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" expe","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exper","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1790,"ts":1715361455.843,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" exper","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1791,"ts":1715361455.93,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experie","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1792,"ts":1715361456.013,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experie","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experien","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1793,"ts":1715361456.119,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experien","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experienc","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1794,"ts":1715361456.199,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experienc","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1795,"ts":1715361456.239,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1796,"ts":1715361456.352,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience t","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1797,"ts":1715361456.386,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience t","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience th","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1798,"ts":1715361456.444,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience th","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience tha","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1799,"ts":1715361456.504,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience tha","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1800,"ts":1715361456.576,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1801,"ts":1715361456.632,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1802,"ts":1715361456.814,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1803,"ts":1715361456.885,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I f","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1804,"ts":1715361457.002,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I f","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I fi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1805,"ts":1715361457.039,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I fi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I fin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1806,"ts":1715361457.09,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I fin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1807,"ts":1715361457.21,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1808,"ts":1715361457.33,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find q","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1809,"ts":1715361457.468,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find q","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find qu","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1810,"ts":1715361457.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find qu","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find qui","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1811,"ts":1715361457.608,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find qui","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quit","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1812,"ts":1715361457.677,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quit","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1813,"ts":1715361457.733,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite ","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1814,"ts":1715361457.849,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite ","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite p","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1815,"ts":1715361458.223,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite p","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pl","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1816,"ts":1715361458.264,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pl","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite ple","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1817,"ts":1715361458.298,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite ple","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite plea","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1818,"ts":1715361458.345,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite plea","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleas","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1819,"ts":1715361458.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleas","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasi","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1820,"ts":1715361458.579,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasi","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasin","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1821,"ts":1715361458.613,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasin","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasing","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1822,"ts":1715361458.67,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasing","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasing.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1823,"ts":1715361458.769,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasing.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasin.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1824,"ts":1715361460.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasin.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasi.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1825,"ts":1715361460.197,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasi.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleas.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1826,"ts":1715361460.309,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleas.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasa.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1827,"ts":1715361460.44,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasa.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasan.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1828,"ts":1715361460.5,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"type":"rich-text","idx":31,"sel":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd"}]}],"prev":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasan.","styles":{}}],"children":[]}],"loc":31}},"meta":{},"metaPrev":{},"map":{"31":{"type":"rich-text","contents":[{"id":"8367b0af-bf46-4ce3-8426-8a799b7c401b","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some notable features of this structured editor:","styles":{}}],"children":[]},{"id":"67b85f0e-f031-4456-a075-dddb59eeb315","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"it's impossible to have \"unbalanced parenthesis\" or a \"missing close-quote\". Deleting a close-paren deletes the whole group.","styles":{}}],"children":[]},{"id":"c13dde06-eb81-4fcd-affa-32089c73e175","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"code formatting is automatic (a la prettier)","styles":{}}],"children":[]},{"id":"98360c6c-42fa-47d7-8db1-05e3ec7ba76f","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"AST locations are much more precise than \"line & column\". Adding code before or after a given identifier doesn't cause the editor to \"lose track of it\"; e.g. error underlines & hover information are trivially preserved.","styles":{}}],"children":[]},{"id":"9c903fd0-5fac-4d7b-b6bd-60890c243604","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"we can attach ","styles":{}},{"type":"text","text":"meta-data","styles":{"bold":true}},{"type":"text","text":" to individual AST nodes; for example marking a node that we would like to be \"traced\" during the next execution.","styles":{}}],"children":[]},{"id":"894e6715-59e3-451a-98a4-277afc6b9158","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"rendering gets more interesting! This rich text block you're reading is technically a comment (as far as the compiler is concerned). Later on you'll see the \"fixture test render plugin\", which takes a toplevel expression of a certain form and renders a nice table of inputs & outputs, highlighting any tests that are failing.","styles":{}}],"children":[]},{"id":"2f898bfe-9acb-4150-874d-c7a41417290a","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"navigation has lots of nice affordances; e.g. typing ","styles":{}},{"type":"text","text":")","styles":{"code":true}},{"type":"text","text":" will take you to the end of whatever s-expression your cursor is currently inside of.","styles":{}}],"children":[]},{"id":"ea842642-0d0f-4271-82f6-f76da5f5d8fe","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"crucially, I've put a lot of effort into making the typing experience as un-surprising as possible. If you're looking at some code, typing in each of the characters of the plain-text representation in order results in that code getting reproduced in the CST. (If you're tried any other structured editors before, you'll know that this is rarely the case!)","styles":{}}],"children":[]},{"id":"f1ae541b-10f9-4dd3-b9de-3801cb8a53fd","type":"bulletListItem","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"There are ","styles":{}},{"type":"text","text":"two levels","styles":{"bold":true}},{"type":"text","text":" of nesting. First, there is a collapsible tree of \"toplevel nodes\", used for broad organization and presentation. Each toplevel node then contains a concrete syntax tree that might represent a toplevel expression, a value or type definition, or, as makes up most of this document, a rich-text block. The order of toplevel expressions in the document, or the level of nesting, makes no difference to the compiler; the first step in evaluation is analyzing eveything and arranging them into dependency order. This two-level structure leads to a \"literate programming\" experience that I find quite pleasant.","styles":{}}],"children":[]}],"loc":31}},"nsMap":{},"nsPrev":{},"id":1829,"ts":1715361460.612,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"idx":31,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"idx":31,"type":"end"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"32":{"type":"normal","top":31,"children":[],"id":32,"collapsed":true}},"nsPrev":{"32":{"type":"normal","top":31,"children":[],"id":32}},"id":1830,"ts":1715361462.433,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"idx":31,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"idx":31,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"32":{"type":"normal","top":31,"children":[],"id":32,"collapsed":false}},"nsPrev":{"32":{"type":"normal","top":31,"children":[],"id":32,"collapsed":true}},"id":1831,"ts":1715361473.42,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"idx":31,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":32,"idx":30},{"type":"ns-top","idx":32},{"idx":31,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"32":{"type":"normal","top":31,"children":[],"id":32,"collapsed":false,"display":{"id":"none","options":null}}},"nsPrev":{"32":{"type":"normal","top":31,"children":[],"id":32,"collapsed":false}},"id":1832,"ts":1715361476.427,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1833,"ts":1715361521.042,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n|\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1834,"ts":1715361521.315,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n|\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1835,"ts":1715361521.403,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1836,"ts":1715361521.714,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {t\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1837,"ts":1715361522.023,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {t\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1838,"ts":1715361522.407,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {y\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1839,"ts":1715361522.813,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {y\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1840,"ts":1715361523.085,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {t\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1841,"ts":1715361523.214,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {t\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {typ\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1842,"ts":1715361523.334,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {typ\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1843,"ts":1715361523.401,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type:\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1844,"ts":1715361523.646,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type:\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1845,"ts":1715361523.681,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: '\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1846,"ts":1715361523.883,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: '\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'ri\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1847,"ts":1715361524.15,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'ri\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'ric\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1848,"ts":1715361524.355,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'ric\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1849,"ts":1715361524.436,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1850,"ts":1715361524.632,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-te\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1851,"ts":1715361524.728,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-te\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-tex\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1852,"ts":1715361524.962,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-tex\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1853,"ts":1715361525.127,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text'\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1854,"ts":1715361525.401,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text'\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text',\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1855,"ts":1715361525.953,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text',\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text', \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1856,"ts":1715361526.032,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| {type: 'rich-text', \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1857,"ts":1715361531.547,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n| \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n|\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1858,"ts":1715361531.745,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n|\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1859,"ts":1715361531.923,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"nsMap":{},"nsPrev":{},"id":1860,"ts":1715361532.276,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n\n","loc":14}},"nsMap":{},"nsPrev":{},"id":1861,"ts":1715361540.801,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n\n","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n|","loc":14}},"nsMap":{},"nsPrev":{},"id":1862,"ts":1715361541.034,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n|","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| ","loc":14}},"nsMap":{},"nsPrev":{},"id":1863,"ts":1715361541.169,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {","loc":14}},"nsMap":{},"nsPrev":{},"id":1864,"ts":1715361541.31,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {t","loc":14}},"nsMap":{},"nsPrev":{},"id":1865,"ts":1715361541.487,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {t","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {typ","loc":14}},"nsMap":{},"nsPrev":{},"id":1866,"ts":1715361541.632,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {typ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type","loc":14}},"nsMap":{},"nsPrev":{},"id":1867,"ts":1715361541.692,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type:","loc":14}},"nsMap":{},"nsPrev":{},"id":1868,"ts":1715361542.047,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type:","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: ","loc":14}},"nsMap":{},"nsPrev":{},"id":1869,"ts":1715361542.15,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: '","loc":14}},"nsMap":{},"nsPrev":{},"id":1870,"ts":1715361542.333,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: '","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'r","loc":14}},"nsMap":{},"nsPrev":{},"id":1871,"ts":1715361542.416,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'r","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw","loc":14}},"nsMap":{},"nsPrev":{},"id":1872,"ts":1715361542.546,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-","loc":14}},"nsMap":{},"nsPrev":{},"id":1873,"ts":1715361542.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-c","loc":14}},"nsMap":{},"nsPrev":{},"id":1874,"ts":1715361542.834,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-c","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-cod","loc":14}},"nsMap":{},"nsPrev":{},"id":1875,"ts":1715361542.922,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-cod","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code'","loc":14}},"nsMap":{},"nsPrev":{},"id":1876,"ts":1715361543.141,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code'","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code',","loc":14}},"nsMap":{},"nsPrev":{},"id":1877,"ts":1715361543.286,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code',","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', ","loc":14}},"nsMap":{},"nsPrev":{},"id":1878,"ts":1715361543.357,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', r","loc":14}},"nsMap":{},"nsPrev":{},"id":1879,"ts":1715361544.011,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', r","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', ra","loc":14}},"nsMap":{},"nsPrev":{},"id":1880,"ts":1715361544.129,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', ra","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw","loc":14}},"nsMap":{},"nsPrev":{},"id":1881,"ts":1715361544.221,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: ","loc":14}},"nsMap":{},"nsPrev":{},"id":1882,"ts":1715361544.398,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: str","loc":14}},"nsMap":{},"nsPrev":{},"id":1883,"ts":1715361544.621,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: str","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: stri","loc":14}},"nsMap":{},"nsPrev":{},"id":1884,"ts":1715361544.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: stri","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: strin","loc":14}},"nsMap":{},"nsPrev":{},"id":1885,"ts":1715361544.74,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: strin","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string","loc":14}},"nsMap":{},"nsPrev":{},"id":1886,"ts":1715361544.889,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, ","loc":14}},"nsMap":{},"nsPrev":{},"id":1887,"ts":1715361544.995,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, l","loc":14}},"nsMap":{},"nsPrev":{},"id":1888,"ts":1715361545.21,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, l","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc","loc":14}},"nsMap":{},"nsPrev":{},"id":1889,"ts":1715361545.361,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc:","loc":14}},"nsMap":{},"nsPrev":{},"id":1890,"ts":1715361545.601,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc:","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: ","loc":14}},"nsMap":{},"nsPrev":{},"id":1891,"ts":1715361545.701,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: ","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: nu","loc":14}},"nsMap":{},"nsPrev":{},"id":1892,"ts":1715361545.807,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: nu","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: num","loc":14}},"nsMap":{},"nsPrev":{},"id":1893,"ts":1715361545.98,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: num","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnb","loc":14}},"nsMap":{},"nsPrev":{},"id":1894,"ts":1715361546.07,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnb","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnbe","loc":14}},"nsMap":{},"nsPrev":{},"id":1895,"ts":1715361546.09,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnbe","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnber","loc":14}},"nsMap":{},"nsPrev":{},"id":1896,"ts":1715361546.142,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnber","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnbe","loc":14}},"nsMap":{},"nsPrev":{},"id":1897,"ts":1715361546.533,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnbe","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnb","loc":14}},"nsMap":{},"nsPrev":{},"id":1898,"ts":1715361546.657,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numnb","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numn","loc":14}},"nsMap":{},"nsPrev":{},"id":1899,"ts":1715361546.795,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numn","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: num","loc":14}},"nsMap":{},"nsPrev":{},"id":1900,"ts":1715361547.142,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: num","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numb","loc":14}},"nsMap":{},"nsPrev":{},"id":1901,"ts":1715361547.321,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: numb","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number","loc":14}},"nsMap":{},"nsPrev":{},"id":1902,"ts":1715361547.408,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1903,"ts":1715361547.586,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"type":"rich-text","idx":0,"sel":"50e95763-10e4-446e-b3fb-103c8c8a05d0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":1,"idx":0},{"type":"ns-top","idx":1},{"type":"rich-text","idx":0,"sel":"50e95763-10e4-446e-b3fb-103c8c8a05d0"}]}],"prev":{"0":{"type":"rich-text","contents":[{"id":"50e95763-10e4-446e-b3fb-103c8c8a05d0","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Structure Editor","styles":{}}],"children":[]},{"id":"6875ae25-05e4-4f1e-9431-578881fb654f","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"A bit about this editor environment","styles":{}}],"children":[]}],"loc":0}},"meta":{},"metaPrev":{},"map":{"0":{"type":"rich-text","contents":[{"id":"50e95763-10e4-446e-b3fb-103c8c8a05d0","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Structured Editor","styles":{}}],"children":[]},{"id":"6875ae25-05e4-4f1e-9431-578881fb654f","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"A bit about this editor environment","styles":{}}],"children":[]}],"loc":0}},"nsMap":{},"nsPrev":{},"id":1904,"ts":1715399101.966,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":3,"idx":30},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"22dcf8b2-852c-4062-a235-3150b52701e9"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":30,"idx":0},{"type":"ns","child":3,"idx":30},{"type":"ns-top","idx":3},{"type":"rich-text","idx":2,"sel":"22dcf8b2-852c-4062-a235-3150b52701e9"}]}],"prev":{"2":{"type":"rich-text","contents":[{"id":"22dcf8b2-852c-4062-a235-3150b52701e9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial takes place in a structured editor, which has some important differences from a standard text editor. The \"structured\" part refers to the fact that the editor's \"source of truth\" representation of your source code is not a long sequence of utf-8 characters, but rather \"structured data\". For many structured editors, the structure of the data is the Abstract Syntax Tree (AST) of the given programming language. Typical programming languages have node types for expressions (variables, numbers, strings, function application, lambdas, array & object literals, infix boolean and prefix unary operators), statements (control structures such as ","styles":{}},{"type":"text","text":"if","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"for","styles":{"code":true}},{"type":"text","text":", and ","styles":{}},{"type":"text","text":"while","styles":{"code":true}},{"type":"text","text":", function and class declaration), and, types (type variables, type application).","styles":{}}],"children":[]},{"id":"4db72981-1cc1-4f35-8e3c-fb37cccbf403","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This has the downside of being quite complicated; both on the implementation side (ensuring that rendering, formatting, and editing each node type works as intended is a huge job) but more importantly: there's a lot of mental overhead for the user, because key strokes might do different things depending on what kind of Node your cursor is in, so you have to be aware of what kind of node (out of dozens of types) you are currently editing.","styles":{}}],"children":[]},{"id":"8e3f048c-0af6-4d0f-a7ed-0ffd4bf406a3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In an attempt to avoid these downsides, this editor works on what I call the \"Concrete Syntax Tree\"; essentially lisp s-expressions (identifiers, strings, lists, and arrays). In my opinion, this strikes a nice balance between the benefits you get from moving beyond \"a jumble of text characters in a file\" while still keeping the representation simple enough that it doesn't get in the way of the editing experience.","styles":{}}],"children":[]},{"id":"982a4c26-848c-48c6-bd61-9eeb08244bf8","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's an example of some syntax in this structured editor:","styles":{}}],"children":[]}],"loc":2}},"meta":{},"metaPrev":{},"map":{"2":{"type":"rich-text","contents":[{"id":"22dcf8b2-852c-4062-a235-3150b52701e9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This tutorial takes place in a structured editor, which has some important differences from a standard text editor. The \"structured\" part refers to the fact that the editor's \"source of truth\" representation of your source code is not a long sequence of utf-8 characters, but rather \"structured data\". ","styles":{}}],"children":[]},{"id":"deabf343-b8ef-4f73-a1e8-6af210a44de9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"For many structured editors, the structure of the data is the Abstract Syntax Tree (AST) of the given programming language. Typical programming languages have node types for expressions (variables, numbers, strings, function application, lambdas, array & object literals, infix boolean and prefix unary operators), statements (control structures such as ","styles":{}},{"type":"text","text":"if","styles":{"code":true}},{"type":"text","text":", ","styles":{}},{"type":"text","text":"for","styles":{"code":true}},{"type":"text","text":", and ","styles":{}},{"type":"text","text":"while","styles":{"code":true}},{"type":"text","text":", function and class declaration), and, types (type variables, type application).","styles":{}}],"children":[]},{"id":"4db72981-1cc1-4f35-8e3c-fb37cccbf403","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"This has the downside of being quite complicated; both on the implementation side (ensuring that rendering, formatting, and editing each node type works as intended is a huge job) but more importantly: there's a lot of mental overhead for the user, because key strokes might do different things depending on what kind of Node your cursor is in, so you have to be aware of what kind of node (out of dozens of types) you are currently editing.","styles":{}}],"children":[]},{"id":"8e3f048c-0af6-4d0f-a7ed-0ffd4bf406a3","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"In an attempt to avoid these downsides, this editor works on what I call the \"Concrete Syntax Tree\"; essentially lisp s-expressions (identifiers, strings, lists, and arrays). In my opinion, this strikes a nice balance between the benefits you get from moving beyond \"a jumble of text characters in a file\" while still keeping the representation simple enough that it doesn't get in the way of the editing experience.","styles":{}}],"children":[]},{"id":"982a4c26-848c-48c6-bd61-9eeb08244bf8","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's an example of some syntax in this structured editor:","styles":{}}],"children":[]}],"loc":2}},"nsMap":{},"nsPrev":{},"id":1905,"ts":1715575726.304,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"5":{"type":"normal","top":4,"children":[],"id":5,"display":{"id":"pre","options":null},"collapsed":false}},"nsPrev":{"5":{"type":"normal","top":4,"children":[],"id":5,"display":{"id":"pre","options":null},"collapsed":"pinned"}},"id":1906,"ts":1715575804.089,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"5":{"type":"normal","top":4,"children":[],"id":5,"collapsed":false}},"nsPrev":{"5":{"type":"normal","top":4,"children":[],"id":5,"display":{"id":"pre","options":null},"collapsed":false}},"id":1907,"ts":1715575816.651,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":4},{"idx":123,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":3},{"idx":18,"type":"end"}]}],"prev":{"4":{"type":"list","values":[6,7,9,18],"loc":4},"123":null},"meta":{},"metaPrev":{},"map":{"4":{"type":"list","values":[6,7,9,18,123],"loc":4},"123":{"type":"blank","loc":123}},"nsMap":{},"nsPrev":{},"id":1908,"ts":1715575819.45,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":4},{"idx":123,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":4},{"idx":123,"type":"start"}]}],"prev":{"123":{"type":"blank","loc":123}},"meta":{},"metaPrev":{},"map":{"123":{"type":"identifier","text":"1","loc":123}},"nsMap":{},"nsPrev":{},"id":1909,"ts":1715575819.694,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":4},{"idx":123,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":4},{"idx":123,"type":"subtext","at":1}]}],"prev":{"123":{"type":"identifier","text":"1","loc":123}},"meta":{},"metaPrev":{},"map":{"123":{"type":"blank","loc":123}},"nsMap":{},"nsPrev":{},"id":1910,"ts":1715575820.064,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":3},{"idx":18,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":5,"idx":26},{"type":"ns-top","idx":5},{"idx":4,"type":"child","at":4},{"idx":123,"type":"subtext","at":0}]}],"prev":{"4":{"type":"list","values":[6,7,9,18,123],"loc":4},"123":{"type":"blank","loc":123}},"meta":{},"metaPrev":{},"map":{"4":{"type":"list","values":[6,7,9,18],"loc":4},"123":null},"nsMap":{},"nsPrev":{},"id":1911,"ts":1715575820.205,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (abbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (sabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1912,"ts":1715876643.152,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (sabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1913,"ts":1715876643.194,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (sliabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1914,"ts":1715876643.258,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (sliabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (sligabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1915,"ts":1715876643.335,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (sligabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slighabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1916,"ts":1715876643.42,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slighabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1917,"ts":1715876643.511,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightlabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1918,"ts":1715876643.622,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightlabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightlyabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1919,"ts":1715876643.681,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightlyabbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightly abbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1920,"ts":1715876644.029,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightly abbreviated to include only the variants that our parser will be concerned with).","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightly abbreviated to include only the variants that our parser will be concerned with)","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1921,"ts":1715876646.466,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":28,"idx":26},{"type":"ns-top","idx":28},{"type":"rich-text","idx":27,"sel":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0"}]}],"prev":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightly abbreviated to include only the variants that our parser will be concerned with)","styles":{}}],"children":[]}],"loc":27}},"meta":{},"metaPrev":{},"map":{"27":{"type":"rich-text","contents":[{"id":"0f58fefe-9678-44b0-8e24-f2ef8503ebd0","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Let's familiarize ourselves with the kinds of syntax we'll be working with: the \"Concrete Syntax Tree\". The \"evaluator\" for this page is set to ","styles":{}},{"type":"text","text":"REPR","styles":{"code":true}},{"type":"text","text":", which simply outputs the JSON representation of the CST for a given toplevel term.","styles":{}}],"children":[]},{"id":"eba71159-e2af-44d4-a078-71921fd1cd72","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Here's the TypeScript type of a CST node (slightly abbreviated to include only the variants that our parser will be concerned with):","styles":{}}],"children":[]}],"loc":27}},"nsMap":{},"nsPrev":{},"id":1922,"ts":1715876647.079,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number}\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1923,"ts":1715876654.019,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} /\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1924,"ts":1715876654.204,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} /\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} //\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1925,"ts":1715876654.34,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} //\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1926,"ts":1715876654.459,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1927,"ts":1715876654.688,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1928,"ts":1715876656.07,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a li\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1929,"ts":1715876656.346,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a li\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a lis\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1930,"ts":1715876656.397,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a lis\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1931,"ts":1715876656.483,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1932,"ts":1715876656.553,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list o\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1933,"ts":1715876656.727,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list o\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1934,"ts":1715876656.912,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of \n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of t\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1935,"ts":1715876657.036,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of t\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of thi\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1936,"ts":1715876657.257,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of thi\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of thing\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1937,"ts":1715876657.365,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of thing\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1938,"ts":1715876657.409,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1939,"ts":1715876657.974,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number}\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1940,"ts":1715876658.524,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} /\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1941,"ts":1715876658.64,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} /\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} //\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1942,"ts":1715876658.808,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} //\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1943,"ts":1715876658.921,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1944,"ts":1715876659.113,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1945,"ts":1715876659.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1946,"ts":1715876660.873,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a s\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1947,"ts":1715876661.97,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a s\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a sq\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1948,"ts":1715876662.169,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a sq\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a squ\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1949,"ts":1715876662.291,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a squ\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a squar\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1950,"ts":1715876662.462,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a squar\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1951,"ts":1715876662.548,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1952,"ts":1715876662.72,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square b\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1953,"ts":1715876662.891,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square b\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bra\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1954,"ts":1715876663.05,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bra\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square brac\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1955,"ts":1715876663.474,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square brac\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracke\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1956,"ts":1715876663.566,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracke\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1957,"ts":1715876663.919,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1958,"ts":1715876664.021,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket li\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1959,"ts":1715876664.161,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket li\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket lis\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1960,"ts":1715876664.196,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket lis\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1961,"ts":1715876664.28,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1962,"ts":1715876664.337,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list o\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1963,"ts":1715876664.456,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list o\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1964,"ts":1715876664.541,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of \n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of t\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1965,"ts":1715876664.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of t\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of th\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1966,"ts":1715876664.697,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of th\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of thi\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1967,"ts":1715876664.737,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of thi\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of thing\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1968,"ts":1715876664.857,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of thing\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1969,"ts":1715876664.913,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1970,"ts":1715876665.117,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1971,"ts":1715876674.431,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\nfirst: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1972,"ts":1715876674.679,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\nfirst: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1973,"ts":1715876675.172,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n  first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1974,"ts":1715876675.305,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n  first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n   first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1975,"ts":1715876675.423,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n   first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1976,"ts":1715876675.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string',\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1977,"ts":1715876676.57,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', /\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1978,"ts":1715876676.754,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', /\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', //\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1979,"ts":1715876676.924,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', //\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1980,"ts":1715876677.037,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1981,"ts":1715876677.571,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1982,"ts":1715876678.404,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1983,"ts":1715876678.587,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1984,"ts":1715876678.852,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${te\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1985,"ts":1715876679.907,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${te\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${tem\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1986,"ts":1715876679.983,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${tem\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${templ\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1987,"ts":1715876680.282,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${templ\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${templa\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1988,"ts":1715876680.323,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${templa\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${templ\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1989,"ts":1715876680.576,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${templ\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${temp\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1990,"ts":1715876680.707,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${temp\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${tem\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1991,"ts":1715876680.83,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${tem\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${te\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1992,"ts":1715876680.969,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${te\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${t\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1993,"ts":1715876681.326,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${t\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1994,"ts":1715876681.484,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${str\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1995,"ts":1715876681.893,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${str\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${stri\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1996,"ts":1715876681.974,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${stri\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${strin\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1997,"ts":1715876682.002,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${strin\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1998,"ts":1715876682.094,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string}\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":1999,"ts":1715876682.438,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string}\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} w\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2000,"ts":1715876682.718,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} w\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} wi\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2001,"ts":1715876682.821,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} wi\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} wit\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2002,"ts":1715876682.887,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} wit\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2003,"ts":1715876682.947,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2004,"ts":1715876683.055,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with \n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2005,"ts":1715876683.361,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${in\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2006,"ts":1715876683.763,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${in\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${int\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2007,"ts":1715876683.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${int\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${inter\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2008,"ts":1715876684.147,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${inter\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpo\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2009,"ts":1715876684.3,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpo\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpola\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2010,"ts":1715876684.546,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpola\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolat\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2011,"ts":1715876684.605,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolat\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolatio\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2012,"ts":1715876684.79,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolatio\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2013,"ts":1715876684.927,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2014,"ts":1715876685.402,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2015,"ts":1715876686.256,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2016,"ts":1715876686.495,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2017,"ts":1715876686.696,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number}\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2018,"ts":1715876699.253,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} /\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2019,"ts":1715876699.43,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} /\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} //\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2020,"ts":1715876699.586,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} //\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2021,"ts":1715876699.758,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // .\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2022,"ts":1715876700.178,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // .\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2023,"ts":1715876700.343,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sp\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2024,"ts":1715876700.49,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sp\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spo\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2025,"ts":1715876700.519,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spo\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spore\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2026,"ts":1715876700.667,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spore\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sporead\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2027,"ts":1715876700.799,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sporead\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sporea\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2028,"ts":1715876701.264,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sporea\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spore\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2029,"ts":1715876701.425,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spore\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spor\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2030,"ts":1715876701.565,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spor\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spo\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2031,"ts":1715876701.686,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spo\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sp\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2032,"ts":1715876701.812,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..sp\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spre\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2033,"ts":1715876702.217,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spre\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2034,"ts":1715876702.396,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2035,"ts":1715876703.547,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2036,"ts":1715876705.165,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a lis\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2037,"ts":1715876705.395,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a lis\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2038,"ts":1715876705.487,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2039,"ts":1715876705.555,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list \n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list .\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2040,"ts":1715876705.669,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list .\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2041,"ts":1715876705.814,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..s\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2042,"ts":1715876706.861,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..s\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..sp\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2043,"ts":1715876706.996,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..sp\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spre\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2044,"ts":1715876707.084,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spre\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..sprea\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2045,"ts":1715876707.168,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..sprea\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spread\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2046,"ts":1715876707.208,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spread\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spreade\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2047,"ts":1715876707.329,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spreade\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spreaded\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2048,"ts":1715876707.392,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":15,"idx":26},{"type":"ns-top","idx":15},{"type":"rich-text","idx":14,"sel":null}]}],"prev":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spreaded\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"meta":{},"metaPrev":{},"map":{"14":{"type":"raw-code","lang":"javascript","raw":"type Node =\n| {type: 'identifier', text: string, loc: number} // abc, 123, a-b%c@, >=, >>=\n| {type: 'list', values: Node[], loc: number} // (a list of things)\n| {type: 'array', values: Node[], loc: number} // [a square bracket list of things]\n| {type: 'string', // \"A ${string} with ${interpolations}\"\n    first: {type: 'stringText', text: string, loc: number},\n    templates: {expr: Node, suffix: {type: 'stringText', text: string, loc: number}},\n    loc: number}\n// I've made the probably-controversial decision of using only a two-dot ellipsis for\n// spreads. This allows for a more fluid editing experience in my opinion (otherwise,\n// two dots would just be invalid syntax, and who wants that). The single dot is\n// reserved for bare-attribute syntax, once our language supports records of some sort.\n| {type: 'spread', contents: Node, loc: number} // ..spread [a list ..spreaded]\n\n// this here is a \"raw code\" type node, which is, sadly, just a big ol' text string,\n// no structured editor goodness here. These will allow us to write the bootstrapping\n// compiler in JavaScript, but we'll move off of them quickly as we get into\n// self-hosting land.\n| {type: 'raw-code', raw: string, loc: number}","loc":14}},"nsMap":{},"nsPrev":{},"id":2049,"ts":1715876707.712,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's  some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2050,"ts":1715876718.986,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's  some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's a some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2051,"ts":1715876719.076,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's a some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2052,"ts":1715876719.172,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an  some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2053,"ts":1715876719.317,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an  some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an e some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2054,"ts":1715876719.394,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an e some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an ex some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2055,"ts":1715876719.563,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an ex some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an exa some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2056,"ts":1715876719.684,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an exa some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an exam some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2057,"ts":1715876719.749,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an exam some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an examp some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2058,"ts":1715876719.883,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an examp some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an exampl some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2059,"ts":1715876719.939,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an exampl some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2060,"ts":1715876720.009,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example  some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2061,"ts":1715876720.235,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example  some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example o some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2062,"ts":1715876720.414,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"prev":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example o some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"meta":{},"metaPrev":{},"map":{"19":{"type":"rich-text","contents":[{"id":"e36ae16e-cd08-42be-821b-f5068cee7a9d","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"And here's an example of some structured code! Feel free to play around with it; everything on this page is editable.","styles":{}}],"children":[]}],"loc":19}},"nsMap":{},"nsPrev":{},"id":2063,"ts":1715876720.497,"libraryRoot":""}],"clipboard":[],"hover":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20}],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":26,"idx":0},{"type":"ns","child":20,"idx":26},{"type":"ns-top","idx":20},{"type":"rich-text","idx":19,"sel":"e36ae16e-cd08-42be-821b-f5068cee7a9d"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,30,26],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal","display":{"id":"none","options":null}},"3":{"type":"normal","top":2,"children":[],"id":3,"display":{"id":"none","options":null},"collapsed":false},"5":{"type":"normal","top":4,"children":[],"id":5,"collapsed":false},"15":{"type":"normal","top":14,"children":[],"id":15,"display":{"id":"none","options":null}},"20":{"type":"normal","top":19,"children":[],"id":20,"display":{"id":"none","options":null}},"26":{"type":"normal","top":25,"children":[28,15,20,5],"id":26,"display":{"id":"none","options":null},"collapsed":false},"28":{"type":"normal","top":27,"children":[],"id":28,"display":{"id":"none","options":null}},"30":{"type":"normal","top":29,"children":[3,34,32],"id":30,"collapsed":false,"display":{"id":"none","options":null}},"32":{"type":"normal","top":31,"children":[],"id":32,"collapsed":false,"display":{"id":"none","options":null}},"34":{"type":"normal","top":33,"children":[],"id":34,"display":{"id":"none","options":null}}},"highlight":[],"evaluator":":repr:"}