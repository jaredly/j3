{"map":{"0":{"type":"rich-text","contents":[{"id":"8fd26af0-7082-4132-96f0-eb9bd9a651aa","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":1},"content":[{"type":"text","text":"Bootstrap (js) parser + compiler","styles":{}}],"children":[]}],"loc":0},"2":{"type":"rich-text","contents":[{"id":"68285dbb-f6ad-428e-a83c-89f93b2af3cf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Parser consumes (Node)s and produces (stmt /  expr)","styles":{}}],"children":[]}],"loc":2},"8":{"type":"raw-code","lang":"javascript","raw":"({type: 'fns', prelude,\n  compile, compile_stmt,\n  parse_stmt: parseStmt, parse_expr: parse,\n  names: s => arr(names(s)),\n  externals_stmt: s => arr(externals(s)),\n  externals_expr: e => arr(externals_expr(e, [])),\n  fromNode: x => x,\n  toNode: x => x})","loc":8},"17":{"type":"blank","loc":17},"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: init})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21},"23":{"type":"raw-code","lang":"javascript","raw":"c = {\n  prim: (prim, loc=-1) => ({type: 'eprim', 0: prim, 1: loc}),\n  int: (v, loc=-1) => ({type: 'pint', 0: v, 1: loc}),\n  bool: (v, loc=-1) => ({type: 'pbool', 0: v, 1: loc}),\n  evar: (text, loc=-1) => ({type: 'evar', 0: text, 1: loc}),\n  app: (target, arg, loc=-1) => ({type: 'eapp', 0: target, 1: arg, 2: loc}),\n  nil: l => c.evar('nil', l),\n  cons: (a, b, l) => c.app(c.app(c.evar('cons', l), a, l), b, l),\n  list: (values, l) => {\n    let v = c.nil(l)\n    for (let i=values.length-1;i>=0;i--) {\n      v = c.cons(values[i], v, l)\n    }\n    return v\n  },\n  \n}","loc":23},"25":{"type":"raw-code","lang":"javascript","raw":"arr = (values) => {\n  let v = nil\n  for (let i=values.length-1;i>=0;i--) {\n    v = cons(values[i], v)\n  }\n  return v\n}","loc":25},"27":{"type":"raw-code","lang":"javascript","raw":"cons = (a, b) => ({type: 'cons', 0: a, 1: b})","loc":27},"29":{"type":"raw-code","lang":"javascript","raw":"nil = {type: 'nil'}","loc":29},"31":{"type":"list","values":[40,41],"loc":31},"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33},"35":{"type":"rich-text","contents":[{"id":"d75f4bc9-5f31-4967-b242-4c02865ab461","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Tree-Walking Evaluator","styles":{}}],"children":[]}],"loc":35},"40":{"type":"raw-code","lang":"javascript","raw":"parse","loc":40},"41":{"type":"identifier","text":"1","loc":41},"42":{"type":"raw-code","lang":"javascript","raw":"parsePrim = node => {\n  const v = +node.text\n  if (!isNaN(v)) {\n    return c.prim(c.int(v, node.loc), node.loc)\n  }\n  if (node.text === 'true' || node.text === 'false') {\n    return c.prim(c.bool(node.text === 'true', node.loc), node.loc)\n  }\n}","loc":42},"46":{"type":"list","values":[48,49],"loc":46},"48":{"type":"raw-code","lang":"javascript","raw":"parse","loc":48},"49":{"type":"identifier","text":"true","loc":49},"50":{"type":"list","values":[52,53],"loc":50},"52":{"type":"raw-code","lang":"javascript","raw":"parse","loc":52},"53":{"type":"array","values":[54,55,56],"loc":53},"54":{"type":"identifier","text":"1","loc":54},"55":{"type":"identifier","text":"2","loc":55},"56":{"type":"identifier","text":"3","loc":56},"57":{"type":"raw-code","lang":"javascript","raw":"pair = (a, b) => ({type: ',', 0: a, 1: b})","loc":57},"61":{"type":"list","values":[63,64],"loc":61},"63":{"type":"raw-code","lang":"javascript","raw":"parse","loc":63},"64":{"type":"string","first":65,"templates":[{"expr":66,"suffix":67}],"loc":64},"65":{"type":"stringText","loc":65,"text":"hi"},"66":{"type":"identifier","text":"1","loc":66},"67":{"type":"stringText","text":"","loc":67},"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68},"70":{"type":"raw-code","lang":"javascript","raw":"foldr = (init, items, f) => items.length === 0 ? init : f(foldr(init, items.slice(1), f), items[0])","loc":70},"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76},"78":{"type":"list","values":[80,81,82],"loc":78},"80":{"type":"identifier","text":",","loc":80},"81":{"type":"raw-code","lang":"javascript","raw":"test","loc":81},"82":{"type":"array","values":[83,116,127,152,170,191,784,1024],"loc":82},"83":{"type":"list","values":[84,88,86],"loc":83},"84":{"type":"identifier","text":",","loc":84},"86":{"type":"string","first":115,"templates":[],"loc":86},"87":{"type":"identifier","text":"@","loc":87},"88":{"type":"list","values":[87,89],"loc":88},"89":{"type":"identifier","text":"1","loc":89},"98":{"type":"raw-code","lang":"javascript","raw":"unwrapArray = value => value.type === 'nil' ? [] : [value[0], ...unwrapArray(value[1])]","loc":98},"109":{"type":"raw-code","lang":"javascript","raw":"unwrapArray(arr([1,2,3]))","loc":109},"111":{"type":"raw-code","lang":"javascript","raw":"valueToString = (v) => {\n    if (Array.isArray(v)) {\n        return `[${v.map(valueToString).join(', ')}]`;\n    }\n\n    if (typeof v === 'object' && v && 'type' in v) {\n        if (v.type === 'cons' || v.type === 'nil') {\n            const un = unwrapArray(v);\n            return '[' + un.map(valueToString).join(' ') + ']';\n        }\n\n        let args = [];\n        for (let i = 0; i in v; i++) {\n            args.push(v[i]);\n        }\n        return `(${v.type}${args\n            .map((arg) => ' ' + valueToString(arg))\n            .join('')})`;\n    }\n    if (typeof v === 'string') {\n        if (v.includes('\"') && !v.includes(\"'\")) {\n            return (\n                \"'\" + JSON.stringify(v).slice(1, -1).replace(/\\\\\"/g, '\"') + \"'\"\n            );\n        }\n        return JSON.stringify(v);\n    }\n    if (typeof v === 'function') {\n        return '<function>';\n    }\n\n    return '' + v;\n};\n","loc":111},"113":{"type":"raw-code","lang":"javascript","raw":"test = v => valueToString(parse(v))","loc":113},"115":{"type":"stringText","loc":115,"text":"(eprim (pint 1 89) 89)"},"116":{"type":"list","values":[117,118,119],"loc":116},"117":{"type":"identifier","text":",","loc":117},"118":{"type":"array","values":[],"loc":118},"119":{"type":"string","first":120,"templates":[],"loc":119},"120":{"type":"stringText","loc":120,"text":"(evar \\\"nil\\\" 118)"},"127":{"type":"list","values":[128,129,130],"loc":127},"128":{"type":"identifier","text":",","loc":128},"129":{"type":"list","values":[131,132,133],"loc":129},"130":{"type":"string","first":999,"templates":[],"loc":130},"131":{"type":"identifier","text":"fn","loc":131},"132":{"type":"array","values":[136],"loc":132},"133":{"type":"identifier","text":"1","loc":133},"136":{"type":"identifier","text":"a","loc":136},"137":{"type":"raw-code","lang":"javascript","raw":"loop = (v, f) => f(v, n => loop(n, f))","loc":137},"140":{"type":"list","values":[142,146],"loc":140},"142":{"type":"identifier","text":"@","loc":142},"146":{"type":"identifier","text":"12","loc":146},"149":{"type":"raw-code","lang":"javascript","raw":"makePairs = array => {\n  const res = [];\n  for (let i=0; i<array.length; i+=2) {\n    res.push([array[i], array[i + 1]]);\n  }\n  return res\n}","loc":149},"152":{"type":"list","values":[153,154,155],"loc":152},"153":{"type":"identifier","text":",","loc":153},"154":{"type":"list","values":[156,157],"loc":154},"155":{"type":"string","first":169,"templates":[],"loc":155},"156":{"type":"identifier","text":"@","loc":156},"157":{"type":"list","values":[160,161,162,163,164,166],"loc":157},"159":{"type":"blank","loc":159},"160":{"type":"identifier","text":"match","loc":160},"161":{"type":"identifier","text":"x","loc":161},"162":{"type":"identifier","text":"1","loc":162},"163":{"type":"identifier","text":"2","loc":163},"164":{"type":"string","first":165,"templates":[],"loc":164},"165":{"type":"stringText","loc":165,"text":"hi"},"166":{"type":"identifier","text":"1","loc":166},"169":{"type":"stringText","loc":169,"text":"(ematch (evar \\\"x\\\" 161) [(, (pprim (pint 1 162) 162) (eprim (pint 2 163) 163)) (, (pstr \\\"hi\\\" 164) (eprim (pint 1 166) 166))] 157)"},"170":{"type":"list","values":[171,172,173],"loc":170},"171":{"type":"identifier","text":",","loc":171},"172":{"type":"list","values":[174,175],"loc":172},"173":{"type":"string","first":1000,"templates":[],"loc":173},"174":{"type":"identifier","text":"@","loc":174},"175":{"type":"list","values":[178,179,186],"loc":175},"177":{"type":"blank","loc":177},"178":{"type":"identifier","text":"let","loc":178},"179":{"type":"array","values":[180,185],"loc":179},"180":{"type":"list","values":[181,182,184],"loc":180},"181":{"type":"identifier","text":",","loc":181},"182":{"type":"identifier","text":"a","loc":182},"184":{"type":"identifier","text":"b","loc":184},"185":{"type":"identifier","text":"c","loc":185},"186":{"type":"identifier","text":"d","loc":186},"188":{"type":"raw-code","lang":"javascript","raw":"p = {\n  prim: (v, loc=-1) => ({type: 'pprim', 0: v, 1: loc}),\n  bool: (v, loc=-1) => ({type: 'pbool', 0: v, 1: loc}),\n  int: (v, loc=-1) => ({type: 'pint', 0: v, 1: loc}),\n  any: loc => ({type: 'pany', 0: loc}),\n  con: (name, args, loc) => ({type: 'pcon', 0: name, 1: arr(args), 2: loc}),\n  cons: (one, two, loc) => p.con('cons', [one, two], loc),\n  nil: loc => p.con('nil', [], loc),\n}","loc":188},"191":{"type":"list","values":[192,193,194],"loc":191},"192":{"type":"identifier","text":",","loc":192},"193":{"type":"list","values":[195,196],"loc":193},"194":{"type":"string","first":1001,"templates":[],"loc":194},"195":{"type":"identifier","text":"@","loc":195},"196":{"type":"list","values":[200,201,209],"loc":196},"198":{"type":"blank","loc":198},"200":{"type":"identifier","text":"let","loc":200},"201":{"type":"array","values":[202,208],"loc":201},"202":{"type":"array","values":[203,207],"loc":202},"203":{"type":"identifier","text":"a","loc":203},"204":{"type":"identifier","text":"b","loc":204},"207":{"type":"spread","contents":204,"loc":207},"208":{"type":"identifier","text":"c","loc":208},"209":{"type":"identifier","text":"d","loc":209},"211":{"type":"rich-text","contents":[{"id":"b188e96a-7452-4d88-8430-9cf830c2407c","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Parser","styles":{}}],"children":[]}],"loc":211},"213":{"type":"rich-text","contents":[{"id":"8e76a41f-02ae-4fa5-beb2-1c769056e297","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Prelude","styles":{}}],"children":[]},{"id":"eee0519b-267f-4dba-b79e-d5c8d1cac4ac","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Some basic handy functions","styles":{}}],"children":[]}],"loc":213},"215":{"type":"rich-text","contents":[{"id":"ad2112fc-475c-4792-a999-68dc69e2495b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Expressions","styles":{}}],"children":[]}],"loc":215},"217":{"type":"rich-text","contents":[{"id":"93144679-d97b-45e4-af01-c151bc706b2e","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Patterns","styles":{}}],"children":[]}],"loc":217},"219":{"type":"rich-text","contents":[{"id":"9a25177e-d6f3-4440-9188-01447ef87df0","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":3},"content":[{"type":"text","text":"Statements","styles":{}}],"children":[]}],"loc":219},"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[values[0].text];\n        if (f) {\n          const res = f(node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221},"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: arr(values.slice(1).map(parseType)), 2: values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225},"227":{"type":"raw-code","lang":"javascript","raw":"testStmt = v => valueToString(parseStmt(v))","loc":227},"229":{"type":"list","values":[231,232,233],"loc":229},"231":{"type":"identifier","text":",","loc":231},"232":{"type":"raw-code","lang":"javascript","raw":"testStmt","loc":232},"233":{"type":"array","values":[234,240,1006,256],"loc":233},"234":{"type":"list","values":[235,236,239],"loc":234},"235":{"type":"identifier","text":",","loc":235},"236":{"type":"list","values":[237,238],"loc":236},"237":{"type":"identifier","text":"@","loc":237},"238":{"type":"identifier","text":"1","loc":238},"239":{"type":"string","first":251,"templates":[],"loc":239},"240":{"type":"list","values":[241,242,243],"loc":240},"241":{"type":"identifier","text":",","loc":241},"242":{"type":"list","values":[244,245],"loc":242},"243":{"type":"string","first":255,"templates":[],"loc":243},"244":{"type":"identifier","text":"@","loc":244},"245":{"type":"list","values":[252,253,254],"loc":245},"247":{"type":"raw-code","lang":"javascript","raw":"testStmt","loc":247},"249":{"type":"list","values":[247,250],"loc":249},"250":{"type":"identifier","text":"1","loc":250},"251":{"type":"stringText","loc":251,"text":"(sexpr (eprim (pint 1 238) 238) 238)"},"252":{"type":"identifier","text":"def","loc":252},"253":{"type":"identifier","text":"hi","loc":253},"254":{"type":"identifier","text":"10","loc":254},"255":{"type":"stringText","loc":255,"text":"(sdef \\\"hi\\\" (eprim (pint 10 254) 254) 245)"},"256":{"type":"list","values":[257,258,259],"loc":256},"257":{"type":"identifier","text":",","loc":257},"258":{"type":"list","values":[260,261],"loc":258},"259":{"type":"string","first":1002,"templates":[],"loc":259},"260":{"type":"identifier","text":"@","loc":260},"261":{"type":"list","values":[264,265,266,270],"loc":261},"263":{"type":"blank","loc":263},"264":{"type":"identifier","text":"defn","loc":264},"265":{"type":"identifier","text":"lol","loc":265},"266":{"type":"array","values":[268,269],"loc":266},"268":{"type":"identifier","text":"a","loc":268},"269":{"type":"identifier","text":"b","loc":269},"270":{"type":"list","values":[271,272,273],"loc":270},"271":{"type":"identifier","text":"+","loc":271},"272":{"type":"identifier","text":"a","loc":272},"273":{"type":"identifier","text":"b","loc":273},"275":{"type":"raw-code","lang":"javascript","raw":"run = v => {\n  const res = evaluate(parse(v), {'$co': a => b => pair(a,b)})\n  if (typeof res === 'number' || typeof res === 'string') return res\n  return valueToString(res)\n}","loc":275},"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node[0]\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286},"292":{"type":"raw-code","lang":"javascript","raw":"set = (obj, k, v) => (obj[k] = v, obj)","loc":292},"335":{"type":"raw-code","lang":"javascript","raw":"stmts = stmts => {\n  if (stmts.type !== 'array') throw new Error('need array')\n  const env = {'$co': a => b => pair(a, b)}\n  let res\n  stmts.values.forEach(stmt => {\n    res = evaluateStmt(parseStmt(stmt), env)\n  });\n  return valueToString(res)\n}\n","loc":335},"369":{"type":"list","values":[371,372,373],"loc":369},"371":{"type":"identifier","text":",","loc":371},"372":{"type":"raw-code","lang":"javascript","raw":"run","loc":372},"373":{"type":"array","values":[374,388,407,539,558,582],"loc":373},"374":{"type":"list","values":[375,376,387],"loc":374},"375":{"type":"identifier","text":",","loc":375},"376":{"type":"list","values":[377,378],"loc":376},"377":{"type":"identifier","text":"@","loc":377},"378":{"type":"list","values":[381,386],"loc":378},"381":{"type":"list","values":[382,383,385],"loc":381},"382":{"type":"identifier","text":"fn","loc":382},"383":{"type":"array","values":[384],"loc":383},"384":{"type":"identifier","text":"x","loc":384},"385":{"type":"identifier","text":"1","loc":385},"386":{"type":"identifier","text":"0","loc":386},"387":{"type":"identifier","text":"1","loc":387},"388":{"type":"list","values":[389,395,391],"loc":388},"389":{"type":"identifier","text":",","loc":389},"390":{"type":"list","values":[392,393,394],"loc":390},"391":{"type":"identifier","text":"1","loc":391},"392":{"type":"identifier","text":",","loc":392},"393":{"type":"identifier","text":"1","loc":393},"394":{"type":"identifier","text":"2","loc":394},"395":{"type":"list","values":[396,397],"loc":395},"396":{"type":"identifier","text":"@","loc":396},"397":{"type":"list","values":[398,400,406],"loc":397},"398":{"type":"identifier","text":"let","loc":398},"399":{"type":"blank","loc":399},"400":{"type":"array","values":[402,390],"loc":400},"402":{"type":"list","values":[403,404,405],"loc":402},"403":{"type":"identifier","text":",","loc":403},"404":{"type":"identifier","text":"x","loc":404},"405":{"type":"identifier","text":"_","loc":405},"406":{"type":"identifier","text":"x","loc":406},"407":{"type":"list","values":[408,409,410],"loc":407},"408":{"type":"identifier","text":",","loc":408},"409":{"type":"list","values":[412,413],"loc":409},"410":{"type":"identifier","text":"10","loc":410},"412":{"type":"identifier","text":"@","loc":412},"413":{"type":"list","values":[414,415,416,417,418,419],"loc":413},"414":{"type":"identifier","text":"match","loc":414},"415":{"type":"identifier","text":"3","loc":415},"416":{"type":"identifier","text":"1","loc":416},"417":{"type":"identifier","text":"2","loc":417},"418":{"type":"identifier","text":"3","loc":418},"419":{"type":"identifier","text":"10","loc":419},"420":{"type":"raw-code","lang":"javascript","raw":"evaluateStmt = (node, env) => {\n  switch (node.type) {\n    case 'sexpr': return evaluate(node[0], env)\n    case 'sdef':\n      const value = evaluate(node[1], env)\n      env[sanitize(node[0])] = value\n      return value\n    case 'sdeftype':\n      const res = {}\n      unwrapArray(node[1]).forEach(({0: name, 1: args}) => {\n        res[sanitize(name)] = env[sanitize(name)] = constrFn(name, args)\n      })\n      return res\n  }\n}\n","loc":420},"422":{"type":"raw-code","lang":"javascript","raw":"constrFn = (name, args) => {\n  const next = (args) => {\n    if (args.type === 'nil') return values => ({type: name, ...values})\n    return values => arg => next(args[1])([...values, arg])\n  }\n  return next(args)([])\n}","loc":422},"455":{"type":"list","values":[457,458,459],"loc":455},"457":{"type":"identifier","text":",","loc":457},"458":{"type":"raw-code","lang":"javascript","raw":"stmts","loc":458},"459":{"type":"array","values":[460,468,478,495,520,756],"loc":459},"460":{"type":"list","values":[461,462,463],"loc":460},"461":{"type":"identifier","text":",","loc":461},"462":{"type":"array","values":[466],"loc":462},"463":{"type":"string","first":467,"templates":[],"loc":463},"466":{"type":"identifier","text":"0","loc":466},"467":{"type":"stringText","loc":467,"text":"0"},"468":{"type":"list","values":[469,470,471],"loc":468},"469":{"type":"identifier","text":",","loc":469},"470":{"type":"array","values":[472,476],"loc":470},"471":{"type":"string","first":477,"templates":[],"loc":471},"472":{"type":"list","values":[473,474,475],"loc":472},"473":{"type":"identifier","text":"def","loc":473},"474":{"type":"identifier","text":"n","loc":474},"475":{"type":"identifier","text":"10","loc":475},"476":{"type":"identifier","text":"n","loc":476},"477":{"type":"stringText","loc":477,"text":"10"},"478":{"type":"list","values":[479,480,481],"loc":478},"479":{"type":"identifier","text":",","loc":479},"480":{"type":"array","values":[482,491],"loc":480},"481":{"type":"string","first":494,"templates":[],"loc":481},"482":{"type":"list","values":[483,484,485,487],"loc":482},"483":{"type":"identifier","text":"defn","loc":483},"484":{"type":"identifier","text":"hi","loc":484},"485":{"type":"array","values":[486],"loc":485},"486":{"type":"identifier","text":"x","loc":486},"487":{"type":"list","values":[488,489,490],"loc":487},"488":{"type":"identifier","text":",","loc":488},"489":{"type":"identifier","text":"x","loc":489},"490":{"type":"identifier","text":"2","loc":490},"491":{"type":"list","values":[492,493],"loc":491},"492":{"type":"identifier","text":"hi","loc":492},"493":{"type":"identifier","text":"5","loc":493},"494":{"type":"stringText","loc":494,"text":"(, 5 2)"},"495":{"type":"list","values":[496,497,498],"loc":495},"496":{"type":"identifier","text":",","loc":496},"497":{"type":"array","values":[499,516],"loc":497},"498":{"type":"string","first":519,"templates":[],"loc":498},"499":{"type":"list","values":[500,508,511,514],"loc":499},"500":{"type":"identifier","text":"deftype","loc":500},"506":{"type":"blank","loc":506},"508":{"type":"list","values":[509,510],"loc":508},"509":{"type":"identifier","text":"option","loc":509},"510":{"type":"identifier","text":"a","loc":510},"511":{"type":"list","values":[512,513],"loc":511},"512":{"type":"identifier","text":"some","loc":512},"513":{"type":"identifier","text":"a","loc":513},"514":{"type":"list","values":[515],"loc":514},"515":{"type":"identifier","text":"none","loc":515},"516":{"type":"list","values":[517,518],"loc":516},"517":{"type":"identifier","text":"some","loc":517},"518":{"type":"identifier","text":"10","loc":518},"519":{"type":"stringText","loc":519,"text":"(some 10)"},"520":{"type":"list","values":[521,522,523],"loc":520},"521":{"type":"identifier","text":",","loc":521},"522":{"type":"array","values":[524,532],"loc":522},"523":{"type":"string","first":538,"templates":[],"loc":523},"524":{"type":"list","values":[525,526,527],"loc":524},"525":{"type":"identifier","text":"deftype","loc":525},"526":{"type":"identifier","text":"lots","loc":526},"527":{"type":"list","values":[528,529,530,531],"loc":527},"528":{"type":"identifier","text":"lol","loc":528},"529":{"type":"identifier","text":"a","loc":529},"530":{"type":"identifier","text":"b","loc":530},"531":{"type":"identifier","text":"c","loc":531},"532":{"type":"list","values":[533,534,535,536],"loc":532},"533":{"type":"identifier","text":"lol","loc":533},"534":{"type":"identifier","text":"1","loc":534},"535":{"type":"identifier","text":"true","loc":535},"536":{"type":"string","first":537,"templates":[],"loc":536},"537":{"type":"stringText","loc":537,"text":"hi"},"538":{"type":"stringText","loc":538,"text":"(lol 1 true \\\"hi\\\")"},"539":{"type":"list","values":[540,541,542],"loc":539},"540":{"type":"identifier","text":",","loc":540},"541":{"type":"list","values":[544,545],"loc":541},"542":{"type":"string","first":550,"templates":[],"loc":542},"543":{"type":"stringText","loc":543,"text":""},"544":{"type":"identifier","text":"@","loc":544},"545":{"type":"string","first":546,"templates":[{"expr":548,"suffix":549}],"loc":545},"546":{"type":"stringText","loc":546,"text":"hi "},"548":{"type":"identifier","text":"1","loc":548},"549":{"type":"stringText","text":".","loc":549},"550":{"type":"stringText","loc":550,"text":"hi 1."},"553":{"type":"stringText","loc":553,"text":""},"558":{"type":"list","values":[559,563,561],"loc":558},"559":{"type":"identifier","text":",","loc":559},"560":{"type":"string","first":562,"templates":[],"loc":560},"561":{"type":"string","first":565,"templates":[],"loc":561},"562":{"type":"stringText","loc":562,"text":"hi"},"563":{"type":"list","values":[564,560],"loc":563},"564":{"type":"identifier","text":"@","loc":564},"565":{"type":"stringText","loc":565,"text":"hi"},"570":{"type":"raw-code","lang":"javascript","raw":"makePrelude = obj => Object.entries(obj).reduce((obj, [k, v]) => (obj[k] = typeof v === 'function' ? '' + v : typeof v === 'string' ? v : JSON.stringify(v), obj), {})","loc":570},"572":{"type":"raw-code","lang":"javascript","raw":"prelude = makePrelude({evaluate,evaluateStmt,unwrapArray,constrFn,sanitize,sanMap,evalPat,kwdRx: kwdString,slash}) ","loc":572},"576":{"type":"blank","loc":576},"582":{"type":"list","values":[583,584,585],"loc":582},"583":{"type":"identifier","text":",","loc":583},"584":{"type":"list","values":[587,588],"loc":584},"585":{"type":"string","first":592,"templates":[],"loc":585},"587":{"type":"identifier","text":"@","loc":587},"588":{"type":"list","values":[589,590,591],"loc":588},"589":{"type":"identifier","text":",","loc":589},"590":{"type":"identifier","text":"1","loc":590},"591":{"type":"identifier","text":"2","loc":591},"592":{"type":"stringText","loc":592,"text":"(, 1 2)"},"593":{"type":"raw-code","lang":"javascript","raw":"compile = ast => _meta => `$env.evaluate(${JSON.stringify(ast)}, $env)`","loc":593},"595":{"type":"raw-code","lang":"javascript","raw":"compile_stmt = ast => _meta => `${ast.type === 'sdef' ? `const ${sanitize(ast[0])} = ` : ast.type === 'sdeftype' ? `const {${\n  unwrapArray(ast[1]).map(c => `\"${c[0]}\": ${sanitize(c[0])}`)\n}} = ` : ''}$env.evaluateStmt(${JSON.stringify(ast)}, $env)`","loc":595},"597":{"type":"rich-text","contents":[{"id":"e8800480-68f3-4e7e-99c1-03c3b168698b","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Analysis","styles":{}}],"children":[]}],"loc":597},"599":{"type":"raw-code","lang":"javascript","raw":"externals = stmt => {\n  switch (stmt.type) {\n    case 'sexpr': return externals_expr(stmt[0], [])\n    case 'sdef': return externals_expr(stmt[1], [stmt[0]])\n    case 'sdeftype': return []\n  }\n  return []\n}","loc":599},"601":{"type":"list","values":[603,615,616],"loc":601},"603":{"type":"identifier","text":",","loc":603},"606":{"type":"identifier","text":",","loc":606},"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607},"611":{"type":"raw-code","lang":"javascript","raw":"externals_expr = (expr, locals) => {\n  switch (expr.type) {\n    case 'evar': return locals.includes(expr[0]) ? [] : [[expr[0], {type: 'value'}, expr[1]]]\n    case 'eapp': return externals_expr(expr[0], locals).concat(externals_expr(expr[1], locals))\n    case 'elambda': return externals_expr(expr[1], locals.concat(expr[0]))\n    case 'eprim': return []\n    case 'estr': return unwrapArray(expr[1]).flatMap(v => externals_expr(v[0], locals))\n    case 'elet': return externals_expr(expr[1], locals).concat(\n      externals_expr(expr[2], locals.concat(expr[0])))\n    case 'ematch':\n      return externals_expr(expr[0], locals).concat(\n        unwrapArray(expr[1]).flatMap(kase => externals_expr(kase[1], locals.concat(pat_names(kase[0])))))\n  }\n  return []\n}","loc":611},"613":{"type":"raw-code","lang":"javascript","raw":"pat_names = pat => {\n  switch (pat.type) {\n    case 'pvar': return [pat[0]]\n    case 'pany': return []\n    case 'pprim': return []\n    case 'pcon':\n      return unwrapArray(pat[1]).flatMap(pat_names)\n  }\n  return []\n}\n","loc":613},"615":{"type":"raw-code","lang":"javascript","raw":"testExt","loc":615},"616":{"type":"array","values":[617,631,646,656,673,814],"loc":616},"617":{"type":"list","values":[606,619,1040],"loc":617},"618":{"type":"identifier","text":"@","loc":618},"619":{"type":"list","values":[618,620],"loc":619},"620":{"type":"identifier","text":"lol","loc":620},"621":{"type":"blank","loc":621},"630":{"type":"stringText","loc":630,"text":"[[\\\"lol\\\", (value), 620]]"},"631":{"type":"list","values":[632,633,1041],"loc":631},"632":{"type":"identifier","text":",","loc":632},"633":{"type":"list","values":[635,636],"loc":633},"634":{"type":"blank","loc":634},"635":{"type":"identifier","text":"@","loc":635},"636":{"type":"list","values":[637,638,640],"loc":636},"637":{"type":"identifier","text":"fn","loc":637},"638":{"type":"array","values":[644],"loc":638},"639":{"type":"identifier","text":",","loc":639},"640":{"type":"list","values":[641,642],"loc":640},"641":{"type":"identifier","text":"+","loc":641},"642":{"type":"identifier","text":"x","loc":642},"644":{"type":"list","values":[639,645],"loc":644},"645":{"type":"identifier","text":"x","loc":645},"646":{"type":"list","values":[647,648,1042],"loc":646},"647":{"type":"identifier","text":",","loc":647},"648":{"type":"list","values":[650,651],"loc":648},"649":{"type":"blank","loc":649},"650":{"type":"identifier","text":"@","loc":650},"651":{"type":"string","first":652,"templates":[{"expr":653,"suffix":654}],"loc":651},"652":{"type":"stringText","loc":652,"text":"hi "},"653":{"type":"identifier","text":"x","loc":653},"654":{"type":"stringText","text":"","loc":654},"656":{"type":"list","values":[657,658,1043],"loc":656},"657":{"type":"identifier","text":",","loc":657},"658":{"type":"list","values":[660,661],"loc":658},"659":{"type":"blank","loc":659},"660":{"type":"identifier","text":"@","loc":660},"661":{"type":"list","values":[662,663,664,670],"loc":661},"662":{"type":"identifier","text":"match","loc":662},"663":{"type":"identifier","text":"m","loc":663},"664":{"type":"list","values":[666,668,669],"loc":664},"665":{"type":"identifier","text":"+","loc":665},"666":{"type":"identifier","text":",","loc":666},"668":{"type":"identifier","text":"a","loc":668},"669":{"type":"identifier","text":"b","loc":669},"670":{"type":"list","values":[665,671],"loc":670},"671":{"type":"identifier","text":"a","loc":671},"673":{"type":"list","values":[674,675,1044],"loc":673},"674":{"type":"identifier","text":",","loc":674},"675":{"type":"list","values":[677,678],"loc":675},"676":{"type":"blank","loc":676},"677":{"type":"identifier","text":"@","loc":677},"678":{"type":"list","values":[681,682,685],"loc":678},"680":{"type":"blank","loc":680},"681":{"type":"identifier","text":"let","loc":681},"682":{"type":"array","values":[683,684],"loc":682},"683":{"type":"identifier","text":"x","loc":683},"684":{"type":"identifier","text":"2","loc":684},"685":{"type":"list","values":[686,687],"loc":685},"686":{"type":"identifier","text":"+","loc":686},"687":{"type":"identifier","text":"x","loc":687},"689":{"type":"raw-code","lang":"javascript","raw":"names = stmt => {\n  switch (stmt.type) {\n    case 'sexpr': return []\n    case 'sdef': return [[stmt[0], {type: 'value'}, stmt[2]]]\n    case 'sdeftype': return unwrapArray(stmt[1]).map(c => [c[0], {type: 'value'}, c[2]])\n  }\n}","loc":689},"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(names(parseStmt(v)))","loc":691},"693":{"type":"list","values":[696,697,699],"loc":693},"696":{"type":"identifier","text":",","loc":696},"697":{"type":"raw-code","lang":"javascript","raw":"testNames","loc":697},"699":{"type":"array","values":[700,707,717],"loc":699},"700":{"type":"list","values":[701,702,705],"loc":700},"701":{"type":"identifier","text":",","loc":701},"702":{"type":"list","values":[703,704],"loc":702},"703":{"type":"identifier","text":"@","loc":703},"704":{"type":"identifier","text":"hi","loc":704},"705":{"type":"string","first":706,"templates":[],"loc":705},"706":{"type":"stringText","loc":706,"text":"[]"},"707":{"type":"list","values":[708,709,710],"loc":707},"708":{"type":"identifier","text":",","loc":708},"709":{"type":"list","values":[711,712],"loc":709},"710":{"type":"string","first":716,"templates":[],"loc":710},"711":{"type":"identifier","text":"@","loc":711},"712":{"type":"list","values":[713,714,715],"loc":712},"713":{"type":"identifier","text":"def","loc":713},"714":{"type":"identifier","text":"x","loc":714},"715":{"type":"identifier","text":"10","loc":715},"716":{"type":"stringText","loc":716,"text":"[[\\\"x\\\", (value), 712]]"},"717":{"type":"list","values":[718,719,720],"loc":717},"718":{"type":"identifier","text":",","loc":718},"719":{"type":"list","values":[721,722],"loc":719},"720":{"type":"string","first":735,"templates":[],"loc":720},"721":{"type":"identifier","text":"@","loc":721},"722":{"type":"list","values":[723,724,727,732],"loc":722},"723":{"type":"identifier","text":"deftype","loc":723},"724":{"type":"list","values":[725,726],"loc":724},"725":{"type":"identifier","text":"option","loc":725},"726":{"type":"identifier","text":"x","loc":726},"727":{"type":"list","values":[730,731],"loc":727},"729":{"type":"blank","loc":729},"730":{"type":"identifier","text":"some","loc":730},"731":{"type":"identifier","text":"x","loc":731},"732":{"type":"list","values":[733],"loc":732},"733":{"type":"identifier","text":"none","loc":733},"735":{"type":"stringText","loc":735,"text":"[[\\\"some\\\", (value), 730], [\\\"none\\\", (value), 733]]"},"738":{"type":"raw-code","lang":"javascript","raw":"testCompileStmt = v => compile_stmt(parseStmt(v))()","loc":738},"740":{"type":"list","values":[742,743],"loc":740},"742":{"type":"raw-code","lang":"javascript","raw":"testCompileStmt","loc":742},"743":{"type":"list","values":[744,747,748,750],"loc":743},"744":{"type":"identifier","text":"deftype","loc":744},"747":{"type":"identifier","text":"card","loc":747},"748":{"type":"list","values":[749],"loc":748},"749":{"type":"identifier","text":"red","loc":749},"750":{"type":"list","values":[751],"loc":750},"751":{"type":"identifier","text":"black","loc":751},"754":{"type":"raw-code","lang":"javascript","raw":"sanitize =  (raw) => {\n    for (let [key, val] of Object.entries(sanMap)) {\n        raw = raw.replaceAll(key, val);\n    }\n    kwdRx.forEach(([rx, res]) => {\n        raw = raw.replaceAll(rx, res);\n    });\n    return raw;\n  }\n","loc":754},"756":{"type":"list","values":[757,758,759],"loc":756},"757":{"type":"identifier","text":",","loc":757},"758":{"type":"array","values":[760,770],"loc":758},"759":{"type":"string","first":774,"templates":[],"loc":759},"760":{"type":"list","values":[761,762,765],"loc":760},"761":{"type":"identifier","text":"deftype","loc":761},"762":{"type":"identifier","text":"a","loc":762},"765":{"type":"list","values":[767,768,769],"loc":765},"767":{"type":"identifier","text":"com,","loc":767},"768":{"type":"identifier","text":"1","loc":768},"769":{"type":"identifier","text":"2","loc":769},"770":{"type":"list","values":[771,772,773],"loc":770},"771":{"type":"identifier","text":"com,","loc":771},"772":{"type":"identifier","text":"1","loc":772},"773":{"type":"identifier","text":"2","loc":773},"774":{"type":"stringText","loc":774,"text":"(com, 1 2)"},"775":{"type":"list","values":[777,778],"loc":775},"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777},"778":{"type":"array","values":[779,783],"loc":778},"779":{"type":"identifier","text":"1","loc":779},"780":{"type":"identifier","text":"2","loc":780},"783":{"type":"spread","contents":780,"loc":783},"784":{"type":"list","values":[785,786,787],"loc":784},"785":{"type":"identifier","text":",","loc":785},"786":{"type":"list","values":[788,789],"loc":786},"787":{"type":"string","first":795,"templates":[],"loc":787},"788":{"type":"identifier","text":"@","loc":788},"789":{"type":"array","values":[790,794],"loc":789},"790":{"type":"identifier","text":"a","loc":790},"791":{"type":"identifier","text":"b","loc":791},"794":{"type":"spread","contents":791,"loc":794},"795":{"type":"stringText","loc":795,"text":"(eapp (eapp (evar \\\"cons\\\" -1) (evar \\\"a\\\" 790) -1) (evar \\\"b\\\" 791) -1)"},"796":{"type":"list","values":[798,799],"loc":796},"798":{"type":"raw-code","lang":"javascript","raw":"parse","loc":798},"799":{"type":"list","values":[800,801],"loc":799},"800":{"type":"identifier","text":"@@","loc":800},"801":{"type":"identifier","text":"1","loc":801},"803":{"loc":803,"type":"raw-code","lang":"javascript","raw":"fromNode = node => {\n  switch (node.type) {\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return\n    case 'identifier':\n      return {type: 'cst/identifier', 0: node.text, 1: node.loc}\n    case 'spread':\n      const inner = fromNode(node.contents)\n      return inner\n      ? {type: 'cst/spread', 0: inner, 1: node.loc}\n      : {type: 'cst/empty-spread', 0: node.loc}\n    case 'array':\n    case 'record':\n    case 'list':\n      return {type: 'cst/' + node.type, 0: arr(node.values.map(fromNode).filter(Boolean)), 1: node.loc}\n    case 'string':\n      return {type: 'cst/string', 0: node.first.text, 1: arr(\n        node.templates.map(item => ({\n          type: ',,',\n          0: fromNode(item.expr) ?? {type: 'cst/string', 0: '', 1: nil},\n          1: item.suffix.text,\n          2: item.suffix.loc,\n        }))\n      ), 2: node.loc}\n  }\n}"},"806":{"type":"raw-code","lang":"javascript","raw":"sanitize('for')","loc":806},"808":{"type":"raw-code","lang":"javascript","raw":"sanMap = {\n    '-': '_',\n    '+': '$pl',\n    '*': '$ti',\n    '=': '$eq',\n    '>': '$gt',\n    '<': '$lt',\n    \"'\": '$qu',\n    '\"': '$dq',\n    ',': '$co',\n    '/': '$sl',\n    ';': '$semi',\n    '@': '$at',\n    '!': '$ex',\n    '|': '$bar',\n    '()': '$unit',\n    '?': '$qe',\n    $: '$$',\n  };\n","loc":808},"810":{"type":"raw-code","lang":"javascript","raw":"kwdRx = (() => {\n  const kwds =\n    'case new var const let if else return super break while for default';\n  const rx = [];\n  kwds.split(' ').forEach((kwd) =>\n    rx.push([new RegExp(`^${kwd}$`, 'g'), '$' + kwd]),\n  );\n  return rx;\n  })();\n\n","loc":810},"812":{"type":"raw-code","lang":"javascript","raw":"kwdString = '[' + kwdRx.map(([r, v]) => `[${r}, \"${v}\"]`).join(', ') + ']'","loc":812},"814":{"type":"list","values":[815,816,1045],"loc":814},"815":{"type":"identifier","text":",","loc":815},"816":{"type":"list","values":[818,837],"loc":816},"817":{"type":"blank","loc":817},"818":{"type":"identifier","text":"@","loc":818},"819":{"type":"blank","loc":819},"821":{"type":"blank","loc":821},"837":{"loc":837,"type":"list","values":[838,839,840,845]},"838":{"loc":838,"type":"identifier","text":"defn"},"839":{"loc":839,"type":"identifier","text":"pat-loop"},"840":{"loc":840,"type":"array","values":[841,842,843,844]},"841":{"loc":841,"type":"identifier","text":"target"},"842":{"loc":842,"type":"identifier","text":"args"},"843":{"loc":843,"type":"identifier","text":"i"},"844":{"loc":844,"type":"identifier","text":"inner"},"845":{"loc":845,"type":"list","values":[846,847,848,849,850,854]},"846":{"loc":846,"type":"identifier","text":"match"},"847":{"loc":847,"type":"identifier","text":"args"},"848":{"loc":848,"type":"array","values":[]},"849":{"loc":849,"type":"identifier","text":"inner"},"850":{"loc":850,"type":"array","values":[851,852]},"851":{"loc":851,"type":"identifier","text":"arg"},"852":{"loc":852,"type":"spread","contents":853},"853":{"loc":853,"type":"identifier","text":"rest"},"854":{"loc":854,"type":"list","values":[855,856,857,863]},"855":{"loc":855,"type":"identifier","text":"compile-pat"},"856":{"loc":856,"type":"identifier","text":"arg"},"857":{"loc":857,"type":"string","first":858,"templates":[{"expr":859,"suffix":860},{"expr":861,"suffix":862}]},"858":{"loc":858,"type":"stringText","text":""},"859":{"loc":859,"type":"identifier","text":"target"},"860":{"loc":860,"type":"stringText","text":"["},"861":{"loc":861,"type":"identifier","text":"i"},"862":{"loc":862,"type":"stringText","text":"]"},"863":{"loc":863,"type":"list","values":[864,865,866,867,871]},"864":{"loc":864,"type":"identifier","text":"pat-loop"},"865":{"loc":865,"type":"identifier","text":"target"},"866":{"loc":866,"type":"identifier","text":"rest"},"867":{"loc":867,"type":"list","values":[868,869,870]},"868":{"loc":868,"type":"identifier","text":"+"},"869":{"loc":869,"type":"identifier","text":"i"},"870":{"loc":870,"type":"identifier","text":"1"},"871":{"loc":871,"type":"identifier","text":"inner"},"872":{"type":"raw-code","lang":"javascript","raw":"slash = (n) =>\n    n.replaceAll(/\\\\./g, (m) => {\n        if (m[1] === 'n') {\n            return '\\n';\n        }\n        if (m[1] === 't') {\n            return '\\t';\n        }\n        if (m[1] === 'r') {\n            return '\\r';\n        }\n        return m[1];\n    })","loc":872},"877":{"loc":877,"type":"rich-text","contents":[{"id":"6d7c6456-dc10-4630-89bc-30a8b9add6bd","type":"heading","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left","level":2},"content":[{"type":"text","text":"Our AST target","styles":{}}],"children":[]}]},"879":{"loc":879,"type":"list","values":[880,881,884,886]},"880":{"loc":880,"type":"identifier","text":"deftype"},"881":{"loc":881,"type":"list","values":[882,883]},"882":{"loc":882,"type":"identifier","text":"array"},"883":{"loc":883,"type":"identifier","text":"a"},"884":{"loc":884,"type":"list","values":[885]},"885":{"loc":885,"type":"identifier","text":"nil"},"886":{"loc":886,"type":"list","values":[887,888,889]},"887":{"loc":887,"type":"identifier","text":"cons"},"888":{"loc":888,"type":"identifier","text":"a"},"889":{"loc":889,"type":"list","values":[890,891]},"890":{"loc":890,"type":"identifier","text":"array"},"891":{"loc":891,"type":"identifier","text":"a"},"893":{"loc":893,"type":"list","values":[894,895,896,899,902,906,910,915]},"894":{"loc":894,"type":"identifier","text":"deftype"},"895":{"loc":895,"type":"identifier","text":"expr"},"896":{"loc":896,"type":"list","values":[897,898]},"897":{"loc":897,"type":"identifier","text":"eprim"},"898":{"loc":898,"type":"identifier","text":"prim"},"899":{"loc":899,"type":"list","values":[900,901]},"900":{"loc":900,"type":"identifier","text":"evar"},"901":{"loc":901,"type":"identifier","text":"string"},"902":{"loc":902,"type":"list","values":[903,904,905]},"903":{"loc":903,"type":"identifier","text":"elambda"},"904":{"loc":904,"type":"identifier","text":"string"},"905":{"loc":905,"type":"identifier","text":"expr"},"906":{"loc":906,"type":"list","values":[907,908,909]},"907":{"loc":907,"type":"identifier","text":"eapp"},"908":{"loc":908,"type":"identifier","text":"expr"},"909":{"loc":909,"type":"identifier","text":"expr"},"910":{"loc":910,"type":"list","values":[911,912,913,914]},"911":{"loc":911,"type":"identifier","text":"elet"},"912":{"loc":912,"type":"identifier","text":"string"},"913":{"loc":913,"type":"identifier","text":"expr"},"914":{"loc":914,"type":"identifier","text":"expr"},"915":{"loc":915,"type":"list","values":[916,917,918]},"916":{"loc":916,"type":"identifier","text":"ematch"},"917":{"loc":917,"type":"identifier","text":"expr"},"918":{"loc":918,"type":"list","values":[919,920]},"919":{"loc":919,"type":"identifier","text":"array"},"920":{"loc":920,"type":"list","values":[921,922,923]},"921":{"loc":921,"type":"identifier","text":","},"922":{"loc":922,"type":"identifier","text":"pat"},"923":{"loc":923,"type":"identifier","text":"expr"},"925":{"loc":925,"type":"list","values":[926,927,928,931]},"926":{"loc":926,"type":"identifier","text":"deftype"},"927":{"loc":927,"type":"identifier","text":"prim"},"928":{"loc":928,"type":"list","values":[929,930]},"929":{"loc":929,"type":"identifier","text":"pint"},"930":{"loc":930,"type":"identifier","text":"int"},"931":{"loc":931,"type":"list","values":[932,933]},"932":{"loc":932,"type":"identifier","text":"pbool"},"933":{"loc":933,"type":"identifier","text":"bool"},"935":{"loc":935,"type":"list","values":[936,937,938,940,943,946,949]},"936":{"loc":936,"type":"identifier","text":"deftype"},"937":{"loc":937,"type":"identifier","text":"pat"},"938":{"loc":938,"type":"list","values":[939]},"939":{"loc":939,"type":"identifier","text":"pany"},"940":{"loc":940,"type":"list","values":[941,942]},"941":{"loc":941,"type":"identifier","text":"pvar"},"942":{"loc":942,"type":"identifier","text":"string"},"943":{"loc":943,"type":"list","values":[944,945]},"944":{"loc":944,"type":"identifier","text":"pprim"},"945":{"loc":945,"type":"identifier","text":"prim"},"946":{"loc":946,"type":"list","values":[947,948]},"947":{"loc":947,"type":"identifier","text":"pstr"},"948":{"loc":948,"type":"identifier","text":"string"},"949":{"loc":949,"type":"list","values":[950,951,952]},"950":{"loc":950,"type":"identifier","text":"pcon"},"951":{"loc":951,"type":"identifier","text":"string"},"952":{"loc":952,"type":"list","values":[953,954]},"953":{"loc":953,"type":"identifier","text":"array"},"954":{"loc":954,"type":"identifier","text":"string"},"956":{"loc":956,"type":"list","values":[957,958,959,962,966]},"957":{"loc":957,"type":"identifier","text":"deftype"},"958":{"loc":958,"type":"identifier","text":"type"},"959":{"loc":959,"type":"list","values":[960,961]},"960":{"loc":960,"type":"identifier","text":"tvar"},"961":{"loc":961,"type":"identifier","text":"int"},"962":{"loc":962,"type":"list","values":[963,964,965]},"963":{"loc":963,"type":"identifier","text":"tapp"},"964":{"loc":964,"type":"identifier","text":"type"},"965":{"loc":965,"type":"identifier","text":"type"},"966":{"loc":966,"type":"list","values":[967,968]},"967":{"loc":967,"type":"identifier","text":"tcon"},"968":{"loc":968,"type":"identifier","text":"string"},"970":{"loc":970,"type":"list","values":[971,972,973,984,988]},"971":{"loc":971,"type":"identifier","text":"deftype"},"972":{"loc":972,"type":"identifier","text":"stmt"},"973":{"loc":973,"type":"list","values":[974,975,976]},"974":{"loc":974,"type":"identifier","text":"sdeftype"},"975":{"loc":975,"type":"identifier","text":"string"},"976":{"loc":976,"type":"list","values":[977,978]},"977":{"loc":977,"type":"identifier","text":"array"},"978":{"loc":978,"type":"list","values":[979,980,981]},"979":{"loc":979,"type":"identifier","text":","},"980":{"loc":980,"type":"identifier","text":"string"},"981":{"loc":981,"type":"list","values":[982,983]},"982":{"loc":982,"type":"identifier","text":"array"},"983":{"loc":983,"type":"identifier","text":"type"},"984":{"loc":984,"type":"list","values":[985,986,987]},"985":{"loc":985,"type":"identifier","text":"sdef"},"986":{"loc":986,"type":"identifier","text":"string"},"987":{"loc":987,"type":"identifier","text":"expr"},"988":{"loc":988,"type":"list","values":[989,990]},"989":{"loc":989,"type":"identifier","text":"sexpr"},"990":{"loc":990,"type":"identifier","text":"expr"},"991":{"type":"comment-node","loc":991,"contents":879},"992":{"type":"comment-node","loc":992,"contents":893},"993":{"type":"comment-node","loc":993,"contents":925},"994":{"type":"comment-node","loc":994,"contents":935},"995":{"type":"comment-node","loc":995,"contents":956},"996":{"type":"comment-node","loc":996,"contents":970},"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.loc}\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997},"999":{"type":"stringText","loc":999,"text":"(elambda \\\"a\\\" (eprim (pint 1 133) 133) 129)"},"1000":{"type":"stringText","loc":1000,"text":"(ematch (evar \\\"c\\\" 185) [(, (pcon \\\",\\\" [(pvar \\\"a\\\" 182) (pvar \\\"b\\\" 184)] 180) (evar \\\"d\\\" 186))] 175)"},"1001":{"type":"stringText","loc":1001,"text":"(ematch (evar \\\"c\\\" 208) [(, (pcon \\\"cons\\\" [(pvar \\\"a\\\" 203) (pvar \\\"b\\\" 204)] 202) (evar \\\"d\\\" 209))] 196)"},"1002":{"type":"stringText","loc":1002,"text":"(sdef \\\"lol\\\" (elambda \\\"a\\\" (elambda \\\"b\\\" (eapp (eapp (evar \\\"+\\\" 271) (evar \\\"a\\\" 272) 270) (evar \\\"b\\\" 273) 270) 261) 261) 261)"},"1006":{"type":"list","values":[1007,1008,1009],"loc":1006},"1007":{"type":"identifier","text":",","loc":1007},"1008":{"type":"list","values":[1010,1011],"loc":1008},"1009":{"type":"string","first":1021,"templates":[],"loc":1009},"1010":{"type":"identifier","text":"@","loc":1010},"1011":{"type":"list","values":[1012,1013,1016,1019],"loc":1011},"1012":{"type":"identifier","text":"deftype","loc":1012},"1013":{"type":"list","values":[1014,1015],"loc":1013},"1014":{"type":"identifier","text":"option","loc":1014},"1015":{"type":"identifier","text":"a","loc":1015},"1016":{"type":"list","values":[1017,1018],"loc":1016},"1017":{"type":"identifier","text":"some","loc":1017},"1018":{"type":"identifier","text":"a","loc":1018},"1019":{"type":"list","values":[1020],"loc":1019},"1020":{"type":"identifier","text":"none","loc":1020},"1021":{"type":"stringText","loc":1021,"text":"(sdeftype \\\"option\\\" [(,, \\\"some\\\" [(tcon \\\"a\\\" 1018)] 1017) (,, \\\"none\\\" [] 1020)])"},"1022":{"type":"raw-code","lang":"javascript","raw":"filterBlanks = values => values.filter(n => !['blank', 'comment', 'rich-text', 'comment-node'].includes(n.type))","loc":1022},"1024":{"type":"list","values":[1025,1026,1027],"loc":1024},"1025":{"type":"identifier","text":",","loc":1025},"1026":{"type":"list","values":[1028,1029],"loc":1026},"1027":{"type":"string","first":1039,"templates":[],"loc":1027},"1028":{"type":"identifier","text":"@","loc":1028},"1029":{"type":"list","values":[1030,1032,1033,1034,1035],"loc":1029},"1030":{"type":"identifier","text":"match","loc":1030},"1032":{"type":"identifier","text":"a","loc":1032},"1033":{"type":"rich-text","contents":[{"id":"46783069-0966-423c-9c5e-f72d6b3509e9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"hi","styles":{}}],"children":[]}],"loc":1033},"1034":{"type":"identifier","text":"1","loc":1034},"1035":{"type":"identifier","text":"1","loc":1035},"1039":{"type":"stringText","loc":1039,"text":"(ematch (evar \\\"a\\\" 1032) [(, (pprim (pint 1 1034) 1034) (eprim (pint 1 1035) 1035))] 1029)"},"1040":{"type":"raw-code","lang":"javascript","loc":1040,"raw":"[[\"lol\",{\"type\":\"value\"},620]]"},"1041":{"type":"raw-code","lang":"javascript","loc":1041,"raw":"[[\"+\",{\"type\":\"value\"},641]]"},"1042":{"type":"raw-code","lang":"javascript","loc":1042,"raw":"[[\"x\",{\"type\":\"value\"},653]]"},"1043":{"type":"raw-code","lang":"javascript","loc":1043,"raw":"[[\"m\",{\"type\":\"value\"},663],[\"+\",{\"type\":\"value\"},665]]"},"1044":{"type":"raw-code","lang":"javascript","loc":1044,"raw":"[[\"+\",{\"type\":\"value\"},686]]"},"1045":{"type":"raw-code","lang":"javascript","loc":1045,"raw":"[[\"compile-pat\",{\"type\":\"value\"},855],[\"+\",{\"type\":\"value\"},868]]"},"-1":{"type":"list","values":[0],"loc":-1}},"root":-1,"meta":{},"history":[{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    \n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":0,"ts":1714748494.575,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    \n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    co\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":1,"ts":1714748494.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    co\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    con\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":2,"ts":1714748495.054,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    con\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    cons\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":3,"ts":1714748495.121,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    cons\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":4,"ts":1714748495.207,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const \n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":5,"ts":1714748495.263,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const \n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const v\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":6,"ts":1714748495.411,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const v\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const va\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":7,"ts":1714748495.55,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const va\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const value\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":8,"ts":1714748495.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const value\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":9,"ts":1714748495.779,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values =\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":10,"ts":1714748495.916,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values =\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = \n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":11,"ts":1714748496.342,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = \n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = f\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":12,"ts":1714748496.607,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = f\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = fil\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":13,"ts":1714748496.683,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = fil\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filt\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":14,"ts":1714748496.723,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filt\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filter\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":15,"ts":1714748496.925,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filter\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterB\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":16,"ts":1714748497.589,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterB\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBl\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":17,"ts":1714748497.875,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBl\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBla\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":18,"ts":1714748497.986,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBla\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":19,"ts":1714748498.079,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":20,"ts":1714748498.569,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(no\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":21,"ts":1714748498.827,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(no\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(nod\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":22,"ts":1714748498.861,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(nod\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":23,"ts":1714748498.943,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":24,"ts":1714748499.011,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.v\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":25,"ts":1714748499.175,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.v\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.val\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":26,"ts":1714748499.332,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.val\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.valu\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":27,"ts":1714748499.417,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.valu\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.value\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":28,"ts":1714748499.453,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.value\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":29,"ts":1714748499.549,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":30,"ts":1714748499.83,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!node.values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":31,"ts":1714748502.947,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(node.values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":32,"ts":1714748505.299,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(values[0])\n    for (let i=1;i<node.values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":33,"ts":1714748506.521,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(node.values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":34,"ts":1714748509.314,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n    \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":35,"ts":1714748515.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n    \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":36,"ts":1714748516.219,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      c\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":37,"ts":1714748516.479,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      c\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      cons\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":38,"ts":1714748516.564,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      cons\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":39,"ts":1714748516.68,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":40,"ts":1714748516.75,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const v\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":41,"ts":1714748516.901,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const v\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const va\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":42,"ts":1714748517.041,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const va\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const valu\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":43,"ts":1714748517.124,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const valu\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const value\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":44,"ts":1714748517.165,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const value\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":45,"ts":1714748517.272,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values =\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":46,"ts":1714748517.381,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values =\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":47,"ts":1714748517.511,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = \n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = fi\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":48,"ts":1714748517.765,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = fi\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = fil\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":49,"ts":1714748517.824,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = fil\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filt\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":50,"ts":1714748517.892,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filt\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filter\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":51,"ts":1714748518.069,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filter\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterB\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":52,"ts":1714748518.452,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterB\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBl\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":53,"ts":1714748518.552,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBl\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlan\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":54,"ts":1714748518.67,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlan\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlank\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":55,"ts":1714748518.753,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlank\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":56,"ts":1714748518.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":57,"ts":1714748518.981,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(no\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":58,"ts":1714748519.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(no\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(nod\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":59,"ts":1714748519.538,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(nod\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":60,"ts":1714748519.607,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":61,"ts":1714748519.751,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.v\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":62,"ts":1714748519.824,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.v\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.val\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":63,"ts":1714748519.972,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.val\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.valu\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":64,"ts":1714748520.039,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.valu\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.value\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":65,"ts":1714748520.093,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.value\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":66,"ts":1714748520.183,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":67,"ts":1714748520.396,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (node.values.length && node.values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (node.values.length && values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":68,"ts":1714748522.828,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (node.values.length && values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":69,"ts":1714748524.254,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[node.values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":70,"ts":1714748526.373,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":222,"idx":220},{"type":"ns-top","idx":222},{"type":"rich-text","idx":221,"sel":null}]}],"prev":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[values[0].text];\n        if (f) {\n          const res = f(node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"meta":{},"metaPrev":{},"map":{"221":{"type":"raw-code","lang":"javascript","raw":"parseStmt = (node) => {\n  switch (node.type) {\n    case 'blank':\n    case 'comment':\n    case 'comment-node':\n    case 'rich-text':\n      return;\n    case 'list':\n      const values = filterBlanks(node.values)\n      if (values.length && values[0].type === 'identifier') {\n        const f = stmtForms[values[0].text];\n        if (f) {\n          const res = f(node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n  }\n  const inner = parse(node)\n  return inner ? {type: 'sexpr', 0: inner, 1: node.loc} : inner\n}","loc":221}},"nsMap":{},"nsPrev":{},"id":71,"ts":1714748529.418,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      \n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":72,"ts":1714748542.5,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      \n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      co\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":73,"ts":1714748543.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      co\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      con\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":74,"ts":1714748543.244,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      con\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":75,"ts":1714748543.368,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const \n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":76,"ts":1714748543.425,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const \n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const v\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":77,"ts":1714748543.672,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const v\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const val\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":78,"ts":1714748543.8,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const val\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const value\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":79,"ts":1714748543.88,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const value\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":80,"ts":1714748543.999,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values =\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":81,"ts":1714748544.126,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values =\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = \n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":82,"ts":1714748544.308,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = \n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = f\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":83,"ts":1714748545.275,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = f\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = fil\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":84,"ts":1714748545.366,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = fil\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filt\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":85,"ts":1714748545.411,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filt\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filter\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":86,"ts":1714748545.566,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filter\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterB\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":87,"ts":1714748545.818,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterB\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBl\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":88,"ts":1714748545.913,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBl\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBla\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":89,"ts":1714748546.011,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBla\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlank\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":90,"ts":1714748546.114,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlank\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":91,"ts":1714748546.144,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":92,"ts":1714748546.335,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(o\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":93,"ts":1714748546.633,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(o\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":94,"ts":1714748546.896,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(i\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":95,"ts":1714748547.182,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(i\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(ite\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":96,"ts":1714748547.296,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(ite\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":97,"ts":1714748547.364,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":98,"ts":1714748547.539,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.v\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":99,"ts":1714748547.623,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.v\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.val\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":100,"ts":1714748547.758,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.val\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.valu\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":101,"ts":1714748547.847,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.valu\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.value\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":102,"ts":1714748547.887,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.value\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":103,"ts":1714748547.974,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":104,"ts":1714748548.152,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (item.values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":105,"ts":1714748551.121,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: item.values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":106,"ts":1714748553.658,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: arr(item.values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: arr(values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":107,"ts":1714748555.684,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":226,"idx":220},{"type":"ns-top","idx":226},{"type":"rich-text","idx":225,"sel":null}]}],"prev":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: arr(values.slice(1).map(parseType)), 2: item.values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"meta":{},"metaPrev":{},"map":{"225":{"type":"raw-code","lang":"javascript","raw":"stmtForms = {\n  deftype(loc, head, ...tail) {\n    if (!head || !tail.length) return\n    const name = head.type === 'identifier' ? head.text : head.type === 'list' && head.values.length >= 1 && head.values[0].type === 'identifier' ? head.values[0].text : null\n    if (!name) return\n    const constructors = tail.map(item => {\n      if (item.type !== 'list') throw new Error(`constructor not a list`)\n      const values = filterBlanks(item.values)\n      if (values.length < 1) throw new Error(`empty list`)\n      return {type: ',,', 0: values[0].text, 1: arr(values.slice(1).map(parseType)), 2: values[0].loc}\n    })\n    return {type: 'sdeftype', 0: name, 1: arr(constructors)}\n  },\n  def(loc, name, value) {\n    if (!name || !value) return\n    if (name.type !== 'identifier') return\n    return {type: 'sdef', 0: name.text, 1: parse(value), 2: loc}\n  },\n  defn(loc, name, args, value) {\n    if (!name || !args || !value) return\n    if (name.type !== 'identifier' || args.type !== 'array') return\n    const body = forms.fn(loc, args, value)\n    if (!body) return\n    return {type: 'sdef', 0: name.text, 1: body, 2: loc}\n  }\n}","loc":225}},"nsMap":{},"nsPrev":{},"id":108,"ts":1714748558.095,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns-top","idx":220},{"idx":219,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns-top","idx":220},{"idx":219,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"220":{"type":"normal","top":219,"children":[222,226,228,248,230],"id":220,"collapsed":true}},"nsPrev":{"220":{"type":"normal","top":219,"children":[222,226,228,248,230],"id":220,"collapsed":false}},"id":109,"ts":1714748565.211,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns-top","idx":218},{"idx":217,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns-top","idx":218},{"idx":217,"type":"end"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":false}},"nsPrev":{"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":true}},"id":110,"ts":1714748566.016,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":111,"ts":1714748571.018,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      con\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":112,"ts":1714748571.805,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      con\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":113,"ts":1714748571.983,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":114,"ts":1714748572.033,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const v\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":115,"ts":1714748572.285,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const v\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const val\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":116,"ts":1714748572.406,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const val\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const value\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":117,"ts":1714748572.486,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const value\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":118,"ts":1714748572.647,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":119,"ts":1714748572.764,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values =\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":120,"ts":1714748572.918,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values =\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":121,"ts":1714748573.037,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = \n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = f\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":122,"ts":1714748573.512,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = f\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filt\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":123,"ts":1714748573.583,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filt\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filter\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":124,"ts":1714748573.799,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filter\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterB\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":125,"ts":1714748574.044,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterB\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBl\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":126,"ts":1714748574.132,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBl\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBla\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":127,"ts":1714748574.238,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBla\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlank\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":128,"ts":1714748574.338,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlank\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":129,"ts":1714748574.375,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":130,"ts":1714748574.57,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(nod\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":131,"ts":1714748575.759,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(nod\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":132,"ts":1714748575.825,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.v\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":133,"ts":1714748575.974,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.v\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.va\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":134,"ts":1714748576.152,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.va\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.valu\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":135,"ts":1714748576.24,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.valu\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.value\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":136,"ts":1714748576.269,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.value\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":137,"ts":1714748576.344,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":138,"ts":1714748576.522,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (node.values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":139,"ts":1714748578.99,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(node.values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":140,"ts":1714748581.035,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, node.values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":141,"ts":1714748583.389,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list':\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': \n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":142,"ts":1714748591.989,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': \n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":143,"ts":1714748592.269,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n      \n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":144,"ts":1714748594.044,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n      \n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    \n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":145,"ts":1714748594.354,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    \n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":146,"ts":1714748594.467,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      const values = filterBlanks(node.values)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":147,"ts":1714748598.72,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      if (!node.values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!node.values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":148,"ts":1714748599.086,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!node.values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":149,"ts":1714748601.209,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":150,"ts":1714748604.11,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!node.values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":151,"ts":1714748606.509,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":152,"ts":1714748608.611,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[node.values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":153,"ts":1714748610.143,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":154,"ts":1714748614.509,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":77,"idx":218},{"type":"ns-top","idx":77},{"type":"rich-text","idx":76,"sel":null}]}],"prev":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(node.values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"meta":{},"metaPrev":{},"map":{"76":{"type":"raw-code","lang":"javascript","raw":"parsePat = node => {\n  switch (node.type) {\n    case 'identifier':\n      switch(node.text) {\n        case '_': return p.any(node.loc)\n        case 'true': case 'false':\n          return p.prim(p.bool(node.text === 'true', node.loc), node.loc)\n      }\n      const v = +node.text\n      if (!isNaN(v)) return p.prim(p.int(v, node.loc), node.loc)\n      return {type: 'pvar', 0: node.text, 1: node.loc}\n    case 'string':\n      return {type: 'pstr', 0: node.first.text, 1: node.loc}\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.con('()', [], node.loc)\n      if (values[0].type !== 'identifier') throw new Error('pat exp must start with identifier')\n      return p.con(values[0].text, values.slice(1).map(parsePat), node.loc)\n    }\n    case 'array':\n      const values = filterBlanks(node.values)\n      if (!values.length) return p.nil(node.loc)\n      let last = values[values.length - 1]\n      let res = last.type === 'spread' ? parsePat(last.contents) : p.cons(parsePat(last), p.nil(node.loc), node.loc)\n      for (let i=values.length - 2; i>=0; i--) {\n        res = p.cons(parsePat(values[i]), res, node.loc)\n      }\n      return res\n  }\n  throw new Error('unknown pat' + JSON.stringify(node))\n}","loc":76}},"nsMap":{},"nsPrev":{},"id":155,"ts":1714748617.768,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns-top","idx":218},{"idx":217,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns-top","idx":218},{"idx":217,"type":"end"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":true}},"nsPrev":{"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":false}},"id":156,"ts":1714748620.656,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns-top","idx":216},{"idx":215,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns-top","idx":216},{"idx":215,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":false}},"nsPrev":{"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":true}},"id":157,"ts":1714748621.306,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}],"end":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"idx":33,"type":"start"}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":158,"ts":1714748644.685,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      c\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":159,"ts":1714748645.039,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      c\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      cion\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":160,"ts":1714748645.142,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      cion\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      cio\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":161,"ts":1714748645.701,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      cio\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      ci\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":162,"ts":1714748645.844,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      ci\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      c\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":163,"ts":1714748645.982,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      c\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      con\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":164,"ts":1714748646.399,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      con\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      cons\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":165,"ts":1714748646.59,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      cons\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":166,"ts":1714748646.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":167,"ts":1714748646.941,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const b\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":168,"ts":1714748647.08,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const b\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const ba\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":169,"ts":1714748647.232,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const ba\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const baku\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":170,"ts":1714748647.329,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const baku\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const bak\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":171,"ts":1714748647.645,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const bak\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const ba\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":172,"ts":1714748647.766,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const ba\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const b\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":173,"ts":1714748647.869,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const b\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":174,"ts":1714748648.001,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const v\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":175,"ts":1714748648.247,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const v\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const va\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":176,"ts":1714748648.431,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const va\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const valu\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":177,"ts":1714748648.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const valu\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":178,"ts":1714748648.722,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values =\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":179,"ts":1714748648.842,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values =\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":180,"ts":1714748648.997,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = \n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = fi\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":181,"ts":1714748649.911,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = fi\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = fil\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":182,"ts":1714748649.991,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = fil\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filt\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":183,"ts":1714748650.027,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filt\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filter\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":184,"ts":1714748650.173,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filter\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterN\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":185,"ts":1714748650.653,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterN\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNu\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":186,"ts":1714748650.748,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNu\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNul\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":187,"ts":1714748651.141,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNul\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNull\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":188,"ts":1714748651.283,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNull\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":189,"ts":1714748651.389,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":190,"ts":1714748651.509,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(no\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":191,"ts":1714748651.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(no\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":192,"ts":1714748651.806,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.v\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":193,"ts":1714748651.952,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.v\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.val\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":194,"ts":1714748652.152,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.val\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.valu\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":195,"ts":1714748652.233,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.valu\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":196,"ts":1714748652.368,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":197,"ts":1714748653.214,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!node.values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":198,"ts":1714748660.9,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (node.values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":199,"ts":1714748663.386,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = node.values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":200,"ts":1714748667.684,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...node.values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":201,"ts":1714748670.356,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const values = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const p = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":202,"ts":1714748689.215,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const p = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const pa = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":203,"ts":1714748689.324,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const pa = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const par = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":204,"ts":1714748689.525,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const par = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parse = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":205,"ts":1714748689.711,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parse = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":206,"ts":1714748689.927,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = values[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = p[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":207,"ts":1714748691.293,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = p[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = pa[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":208,"ts":1714748691.391,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = pa[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = par[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":209,"ts":1714748691.548,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = par[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parse[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":210,"ts":1714748691.703,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parse[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":211,"ts":1714748691.749,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<values.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<p.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":212,"ts":1714748693.986,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<p.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<pa.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":213,"ts":1714748694.109,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<pa.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<par.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":214,"ts":1714748694.285,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<par.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parse.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":215,"ts":1714748694.461,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parse.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":216,"ts":1714748694.506,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, values[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, p[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":217,"ts":1714748695.873,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, p[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, pa[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":218,"ts":1714748695.975,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, pa[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, par[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":219,"ts":1714748696.124,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, par[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parse[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":220,"ts":1714748696.288,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parse[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":221,"ts":1714748696.512,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = node.values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":222,"ts":1714748698.654,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNulls(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNull(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":223,"ts":1714748704.585,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNull(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNul(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":224,"ts":1714748704.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNul(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNu(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":225,"ts":1714748704.858,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterNu(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterN(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":226,"ts":1714748704.988,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterN(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filter(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":227,"ts":1714748705.208,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filter(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterB(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":228,"ts":1714748705.443,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterB(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBl(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":229,"ts":1714748705.572,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBl(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBlan(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":230,"ts":1714748705.731,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBlan(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBlank(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":231,"ts":1714748705.802,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":34,"idx":216},{"type":"ns-top","idx":34},{"type":"rich-text","idx":33,"sel":null}]}],"prev":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBlank(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"meta":{},"metaPrev":{},"map":{"33":{"type":"raw-code","lang":"javascript","raw":"parse = node => {\n  switch (node.type) {\n    case 'identifier': {\n      return parsePrim(node) || c.evar(node.text, node.loc)\n    }\n    case 'string': {\n      const exprs = node.templates.map(t => parse(t.expr))\n      return {type: 'estr', 0: node.first.text, 1: arr(\n        node.templates.map((t, i) => pair(exprs[i], t.suffix.text))\n      ), 2: node.loc}\n    }\n    case 'list': {\n      const values = filterBlanks(node.values)\n      if (!values.length) return c.evar('()', node.loc)\n      if (values[0].type === 'identifier') {\n        const first = values[0].text;\n        if (forms[first]) {\n          const res = forms[first](node.loc, ...values.slice(1))\n          if (res) return res\n        }\n      }\n      const parsed = values.map(parse)\n      let res = parsed[0]\n      for (let i=1; i<parsed.length; i++) {\n        res = c.app(res, parsed[i], node.loc)\n      }\n      return res\n    }\n    case 'array': {\n      if (!node.values.length) return c.evar('nil', node.loc)\n      let last = node.values[node.values.length - 1]\n      let res = last.type === 'spread'\n        ? parse(last.contents)\n        : c.cons(parse(last), c.nil(node.loc), node.loc)\n      for (let i=node.values.length - 2; i>=0; i--) {\n        res = c.cons(parse(node.values[i]), res)\n      }\n      return res\n    }\n    case 'raw-code':\n      return {type: 'estr', 0: node.raw, 1: nil, 2: node.loc}\n  }\n  throw new Error(`cant parse ${JSON.stringify(node)}`)\n}","loc":33}},"nsMap":{},"nsPrev":{},"id":232,"ts":1714748705.946,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns-top","idx":216},{"idx":215,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns-top","idx":216},{"idx":215,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":true}},"nsPrev":{"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":false}},"id":233,"ts":1714749364.931,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns-top","idx":216},{"idx":215,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns-top","idx":216},{"idx":215,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":false}},"nsPrev":{"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":true}},"id":234,"ts":1714749377.602,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":6,"idx":82},{"idx":784,"type":"child","at":2},{"idx":787,"type":"end"}]}],"prev":{"82":{"type":"array","values":[83,116,127,152,170,191,784],"loc":82},"1024":null,"1025":null,"1026":null,"1027":null},"meta":{},"metaPrev":{},"map":{"82":{"type":"array","values":[83,116,127,152,170,191,784,1024],"loc":82},"1024":{"type":"list","values":[1025,1026,1027],"loc":1024},"1025":{"type":"identifier","text":",","loc":1025},"1026":{"type":"blank","loc":1026},"1027":{"type":"blank","loc":1027}},"nsMap":{},"nsPrev":{},"id":235,"ts":1714749387.349,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"inside"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"start"}]}],"prev":{"1026":{"type":"blank","loc":1026}},"meta":{},"metaPrev":{},"map":{"1026":{"type":"list","values":[],"loc":1026}},"nsMap":{},"nsPrev":{},"id":236,"ts":1714749388.14,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":0},{"idx":1028,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"inside"}]}],"prev":{"1026":{"type":"list","values":[],"loc":1026},"1028":null},"meta":{},"metaPrev":{},"map":{"1026":{"type":"list","values":[1028],"loc":1026},"1028":{"type":"identifier","text":"@","loc":1028}},"nsMap":{},"nsPrev":{},"id":237,"ts":1714749388.313,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"inside"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":0},{"idx":1028,"type":"subtext","at":1}]}],"prev":{"1026":{"type":"list","values":[1028],"loc":1026},"1029":null},"meta":{},"metaPrev":{},"map":{"1026":{"type":"list","values":[1028,1029],"loc":1026},"1029":{"type":"list","values":[],"loc":1029}},"nsMap":{},"nsPrev":{},"id":238,"ts":1714749389.027,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"inside"}]}],"prev":{"1029":{"type":"list","values":[],"loc":1029},"1030":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030],"loc":1029},"1030":{"type":"identifier","text":"m","loc":1030}},"nsMap":{},"nsPrev":{},"id":239,"ts":1714749389.415,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"subtext","at":5}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"subtext","at":1}]}],"prev":{"1030":{"type":"identifier","text":"m","loc":1030}},"meta":{},"metaPrev":{},"map":{"1030":{"type":"identifier","text":"march","loc":1030}},"nsMap":{},"nsPrev":{},"id":240,"ts":1714749389.557,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":1},{"idx":1031,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"subtext","at":5}]}],"prev":{"1029":{"type":"list","values":[1030],"loc":1029},"1031":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1031],"loc":1029},"1031":{"type":"blank","loc":1031}},"nsMap":{},"nsPrev":{},"id":241,"ts":1714749390.037,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":1},{"idx":1031,"type":"start"}]}],"prev":{"1029":{"type":"list","values":[1030,1031],"loc":1029},"1031":{"type":"blank","loc":1031}},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030],"loc":1029},"1031":null},"nsMap":{},"nsPrev":{},"id":242,"ts":1714749390.513,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"subtext","at":5}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"end"}]}],"prev":{"1030":{"type":"identifier","text":"march","loc":1030}},"meta":{},"metaPrev":{},"map":{"1030":{"type":"identifier","text":"match","loc":1030}},"nsMap":{},"nsPrev":{},"id":243,"ts":1714749390.622,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":1},{"idx":1032,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":0},{"idx":1030,"type":"subtext","at":5}]}],"prev":{"1029":{"type":"list","values":[1030],"loc":1029},"1032":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032],"loc":1029},"1032":{"type":"blank","loc":1032}},"nsMap":{},"nsPrev":{},"id":244,"ts":1714749391.622,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":1},{"idx":1032,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":1},{"idx":1032,"type":"start"}]}],"prev":{"1032":{"type":"blank","loc":1032}},"meta":{},"metaPrev":{},"map":{"1032":{"type":"identifier","text":"a","loc":1032}},"nsMap":{},"nsPrev":{},"id":245,"ts":1714749391.744,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":1},{"idx":1032,"type":"subtext","at":1}]}],"prev":{"1029":{"type":"list","values":[1030,1032],"loc":1029},"1033":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033],"loc":1029},"1033":{"type":"blank","loc":1033}},"nsMap":{},"nsPrev":{},"id":246,"ts":1714749392.142,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"start"}]}],"prev":{"1033":{"type":"blank","loc":1033}},"meta":{},"metaPrev":{},"map":{"1033":{"type":"comment","text":"","loc":1033}},"nsMap":{},"nsPrev":{},"id":247,"ts":1714749392.295,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":0}]}],"prev":{"1033":{"type":"comment","text":"","loc":1033}},"meta":{},"metaPrev":{},"map":{"1033":{"type":"comment","text":"a","loc":1033}},"nsMap":{},"nsPrev":{},"id":248,"ts":1714749392.499,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":3},{"idx":1034,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":1}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033],"loc":1029},"1034":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034],"loc":1029},"1034":{"type":"blank","loc":1034}},"nsMap":{},"nsPrev":{},"id":249,"ts":1714749392.976,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":3},{"idx":1034,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":3},{"idx":1034,"type":"start"}]}],"prev":{"1034":{"type":"blank","loc":1034}},"meta":{},"metaPrev":{},"map":{"1034":{"type":"identifier","text":"1","loc":1034}},"nsMap":{},"nsPrev":{},"id":250,"ts":1714749393.463,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":4},{"idx":1035,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":3},{"idx":1034,"type":"subtext","at":1}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034],"loc":1029},"1035":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035],"loc":1029},"1035":{"type":"blank","loc":1035}},"nsMap":{},"nsPrev":{},"id":251,"ts":1714749394.023,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":4},{"idx":1035,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"idx":82,"type":"child","at":7},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":4},{"idx":1035,"type":"start"}]}],"prev":{"1035":{"type":"blank","loc":1035}},"meta":{},"metaPrev":{},"map":{"1035":{"type":"identifier","text":"1","loc":1035}},"nsMap":{},"nsPrev":{},"id":252,"ts":1714749394.131,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":1}]}],"prev":{"1033":{"type":"comment","text":"a","loc":1033}},"meta":{},"metaPrev":{},"map":{"1033":{"type":"comment","text":"","loc":1033}},"nsMap":{},"nsPrev":{},"id":253,"ts":1714749395.983,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"subtext","at":0}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035],"loc":1029},"1033":{"type":"comment","text":"","loc":1033}},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035],"loc":1029},"1033":{"type":"blank","loc":1033}},"nsMap":{},"nsPrev":{},"id":254,"ts":1714749396.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"type":"rich-text","idx":1033,"sel":"46783069-0966-423c-9c5e-f72d6b3509e9"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":2},{"idx":1033,"type":"start"}]}],"prev":{"1033":{"type":"blank","loc":1033}},"meta":{},"metaPrev":{},"map":{"1033":{"type":"rich-text","contents":[{"id":"46783069-0966-423c-9c5e-f72d6b3509e9","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"hi","styles":{}}],"children":[]}],"loc":1033}},"nsMap":{},"nsPrev":{},"id":255,"ts":1714749396.823,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":4},{"idx":1035,"type":"subtext","at":1}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035],"loc":1029},"1036":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036],"loc":1029},"1036":{"type":"blank","loc":1036}},"nsMap":{},"nsPrev":{},"id":256,"ts":1714749402.508,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"start"}]}],"prev":{"1036":{"type":"blank","loc":1036}},"meta":{},"metaPrev":{},"map":{"1036":{"type":"identifier","text":"2","loc":1036}},"nsMap":{},"nsPrev":{},"id":257,"ts":1714749403.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":6},{"idx":1037,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"subtext","at":1}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036],"loc":1029},"1037":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036,1037],"loc":1029},"1037":{"type":"blank","loc":1037}},"nsMap":{},"nsPrev":{},"id":258,"ts":1714749404.591,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":7},{"idx":1038,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":6},{"idx":1037,"type":"start"}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036,1037],"loc":1029},"1038":null},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036,1037,1038],"loc":1029},"1038":{"type":"blank","loc":1038}},"nsMap":{},"nsPrev":{},"id":259,"ts":1714749405.821,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":7},{"idx":1038,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":7},{"idx":1038,"type":"start"}]}],"prev":{"1038":{"type":"blank","loc":1038}},"meta":{},"metaPrev":{},"map":{"1038":{"type":"identifier","text":"3","loc":1038}},"nsMap":{},"nsPrev":{},"id":260,"ts":1714749406.385,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":7},{"idx":1038,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":7},{"idx":1038,"type":"subtext","at":1}]}],"prev":{"1038":{"type":"identifier","text":"3","loc":1038}},"meta":{},"metaPrev":{},"map":{"1038":{"type":"blank","loc":1038}},"nsMap":{},"nsPrev":{},"id":261,"ts":1714749407.946,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":6},{"idx":1037,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":7},{"idx":1038,"type":"subtext","at":0}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036,1037,1038],"loc":1029},"1038":{"type":"blank","loc":1038}},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036,1037],"loc":1029},"1038":null},"nsMap":{},"nsPrev":{},"id":262,"ts":1714749408.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":6},{"idx":1037,"type":"end"}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036,1037],"loc":1029},"1037":{"type":"blank","loc":1037}},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036],"loc":1029},"1037":null},"nsMap":{},"nsPrev":{},"id":263,"ts":1714749408.339,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"end"}]}],"prev":{"1036":{"type":"identifier","text":"2","loc":1036}},"meta":{},"metaPrev":{},"map":{"1036":{"type":"blank","loc":1036}},"nsMap":{},"nsPrev":{},"id":264,"ts":1714749408.705,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":4},{"idx":1035,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":1},{"idx":1026,"type":"child","at":1},{"idx":1029,"type":"child","at":5},{"idx":1036,"type":"subtext","at":0}]}],"prev":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035,1036],"loc":1029},"1036":{"type":"blank","loc":1036}},"meta":{},"metaPrev":{},"map":{"1029":{"type":"list","values":[1030,1032,1033,1034,1035],"loc":1029},"1036":null},"nsMap":{},"nsPrev":{},"id":265,"ts":1714749409.076,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":2},{"idx":1027,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":7,"idx":82},{"idx":1024,"type":"child","at":2},{"idx":1027,"type":"subtext","at":0}]}],"prev":{"1027":{"type":"blank","loc":1027},"1039":null},"meta":{},"metaPrev":{},"map":{"1027":{"type":"string","first":1039,"templates":[],"loc":1027},"1039":{"type":"stringText","loc":1039,"text":"(ematch (evar \\\"a\\\" 1032) [(, (pprim (pint 1 1034) 1034) (eprim (pint 1 1035) 1035))] 1029)"}},"nsMap":{},"nsPrev":{},"id":266,"ts":1714749418.739,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns-top","idx":218},{"idx":217,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns-top","idx":218},{"idx":217,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":false}},"nsPrev":{"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":true}},"id":267,"ts":1714749449.171,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":268,"ts":1714749468.593,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    co\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":269,"ts":1714749470.669,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    co\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    con\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":270,"ts":1714749470.918,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    con\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":271,"ts":1714749470.923,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":272,"ts":1714749470.973,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":273,"ts":1714749473.93,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n   \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":274,"ts":1714749474.192,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n   \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n  \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":275,"ts":1714749474.508,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n  \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":276,"ts":1714749474.65,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n \n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":277,"ts":1714749475.009,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":278,"ts":1714749475.23,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = fargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":279,"ts":1714749478.724,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = fargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = fiargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":280,"ts":1714749478.864,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = fiargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":281,"ts":1714749479.202,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filtargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":282,"ts":1714749479.364,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filtargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":283,"ts":1714749479.519,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterNargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":284,"ts":1714749479.892,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterNargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterNuargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":285,"ts":1714749480.048,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterNuargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterNargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":286,"ts":1714749480.463,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterNargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":287,"ts":1714749480.935,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":288,"ts":1714749481.118,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":289,"ts":1714749481.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlaargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":290,"ts":1714749481.354,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlaargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlankargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":291,"ts":1714749481.446,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlankargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanksargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":292,"ts":1714749481.567,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanksargs.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":293,"ts":1714749481.707,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values.map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":294,"ts":1714749484.584,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(fibindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":295,"ts":1714749492.161,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(fibindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":296,"ts":1714749492.236,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filtbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":297,"ts":1714749492.263,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filtbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":298,"ts":1714749492.456,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filter(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":299,"ts":1714749492.721,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filter(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":300,"ts":1714749493.27,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":301,"ts":1714749493.422,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":302,"ts":1714749493.556,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlabindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":303,"ts":1714749493.678,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlabindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlankbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":304,"ts":1714749493.757,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlankbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanksbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":305,"ts":1714749493.878,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanksbindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":306,"ts":1714749494.023,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values)\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":307,"ts":1714749496.766,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(frest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":308,"ts":1714749501.628,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(frest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":309,"ts":1714749501.703,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filtrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":310,"ts":1714749501.839,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filtrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":311,"ts":1714749501.964,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":312,"ts":1714749502.684,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":313,"ts":1714749502.812,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlarest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":314,"ts":1714749502.933,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlarest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlankrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":315,"ts":1714749503.021,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlankrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlanksrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":316,"ts":1714749503.065,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlanksrest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlanks(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":317,"ts":1714749503.293,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlanks(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlanks(rest))\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":318,"ts":1714749504.777,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":69,"idx":216},{"type":"ns-top","idx":69},{"type":"rich-text","idx":68,"sel":null}]}],"prev":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(filterBlanks(rest))\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"meta":{},"metaPrev":{},"map":{"68":{"type":"raw-code","lang":"javascript","raw":"forms = {\n  fn: (loc, args, body) => {\n    if (!args || !body) return\n    if (args.type !== 'array') return\n    const pats = filterBlanks(args.values).map(parsePat)\n    return foldr(parse(body), pats, (body, arg) =>\n      arg.type === 'pvar' ?\n    ({type: 'elambda', 0: arg[0], 1: body, 2: loc}) : {\n      type: 'elambda', 0: '$arg', 1: {type: 'ematch', 0: {type: 'evar', 0: '$arg', 1: loc}, 1: arr([pair(arg, body)]), 2: loc}}\n    )\n  },\n  let: (loc, bindings, body) => {\n    if (!bindings || !body) return\n    if (bindings.type !== 'array') return\n    const pairs = makePairs(filterBlanks(bindings.values))\n    return foldr(parse(body), pairs, (body, [pat, init]) => {\n      if (pat.type === 'identifier') {\n        return {type: 'elet', 0: pat.text, 1: parse(init), 2: body, 3: loc}\n      }\n      return {type: 'ematch', 0: parse(init), 1: arr([pair(parsePat(pat), body)]), 2: loc}\n    })\n  },\n  match: (loc, target, ...rest) => {\n    if (!target || !rest.length) return\n    const cases = makePairs(rest)\n    return {type: 'ematch', 0: parse(target), 1: arr(cases.map(([pat, body]) => pair(parsePat(pat), parse(body)))), 2: loc}\n  },\n  '@': (loc, inner) => ({type: 'equot', 0: parse(inner), 1: loc}),\n  '@@': (loc, inner) => ({type: 'equot', 0: fromNode(inner), 1: loc}),\n  '@!': (loc, inner) => ({type: 'equot', 0: parseStmt(inner), 1: loc}),\n  'if': (loc, cond, yes, no) => ({type: 'ematch', 0: parse(cond), 1: arr([pair(\n    {type: 'pprim', 0: {type: 'pbool', 0: true, 1: loc}, 1: loc},\n    parse(yes)\n    ), pair(\n      {type: 'pany', 0: loc},\n      parse(no)\n    )\n  ])}),\n}","loc":68}},"nsMap":{},"nsPrev":{},"id":319,"ts":1714749531.535,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":320,"ts":1714749604.527,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    i\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":321,"ts":1714749604.887,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    i\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":322,"ts":1714749605.22,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":323,"ts":1714749605.45,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (v\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":324,"ts":1714749605.623,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (v\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (va\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":325,"ts":1714749605.776,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (va\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (valu\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":326,"ts":1714749605.912,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (valu\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (value\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":327,"ts":1714749605.968,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (value\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":328,"ts":1714749606.088,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":329,"ts":1714749606.286,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0]\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":330,"ts":1714749606.529,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0]\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":331,"ts":1714749606.816,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].t\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":332,"ts":1714749606.965,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].t\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].ty\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":333,"ts":1714749607.045,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].ty\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":334,"ts":1714749607.073,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":335,"ts":1714749607.188,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":336,"ts":1714749607.336,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe ==\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":337,"ts":1714749607.457,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe ==\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":338,"ts":1714749607.646,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":339,"ts":1714749607.996,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":340,"ts":1714749608.125,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":341,"ts":1714749608.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].ty\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":342,"ts":1714749608.378,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].ty\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":343,"ts":1714749608.63,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":344,"ts":1714749608.775,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyoe\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":345,"ts":1714749609.068,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].tyo\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].ty\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":346,"ts":1714749609.205,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].ty\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].typ\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":347,"ts":1714749609.48,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].typ\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":348,"ts":1714749609.586,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":349,"ts":1714749609.679,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type ==\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":350,"ts":1714749609.96,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type ==\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type ===\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":351,"ts":1714749610.089,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type ===\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === '\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":352,"ts":1714749610.324,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === '\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'i\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":353,"ts":1714749610.635,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'i\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'ide\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":354,"ts":1714749610.833,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'ide\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'iden\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":355,"ts":1714749610.892,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'iden\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'ident\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":356,"ts":1714749611.099,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'ident\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identi\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":357,"ts":1714749611.198,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identi\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identif\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":358,"ts":1714749611.302,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identif\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifi\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":359,"ts":1714749611.392,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifi\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier'\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":360,"ts":1714749611.563,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier'\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":361,"ts":1714749611.832,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' &\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":362,"ts":1714749611.937,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' &\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' &&\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":363,"ts":1714749612.08,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' &&\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":364,"ts":1714749612.176,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && n\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":365,"ts":1714749612.227,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && n\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && no\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":366,"ts":1714749612.328,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && no\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && nod\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":367,"ts":1714749612.372,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && nod\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && node\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":368,"ts":1714749612.452,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && node\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && nod\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":369,"ts":1714749612.919,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && nod\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && no\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":370,"ts":1714749613.037,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && no\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && n\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":371,"ts":1714749613.177,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && n\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":372,"ts":1714749613.336,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && v\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":373,"ts":1714749613.736,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && v\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && val\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":374,"ts":1714749613.972,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && val\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && valu\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":375,"ts":1714749614.06,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && valu\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":376,"ts":1714749614.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}],"end":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"idx":997,"type":"start"}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (vvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":377,"ts":1714749618.162,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (vvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (vavalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":378,"ts":1714749618.36,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (vavalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (valuvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":379,"ts":1714749618.462,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (valuvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (valuesvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":380,"ts":1714749618.61,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (valuesvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":381,"ts":1714749618.661,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":382,"ts":1714749618.898,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.levalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":383,"ts":1714749619.011,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.levalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lenvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":384,"ts":1714749619.145,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lenvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lengtvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":385,"ts":1714749619.245,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lengtvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lengthvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":386,"ts":1714749619.309,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.lengthvalues[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":387,"ts":1714749619.467,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length =values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":388,"ts":1714749619.561,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length =values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length ==values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":389,"ts":1714749619.693,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length ==values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length ===values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":390,"ts":1714749619.829,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length ===values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":391,"ts":1714749619.973,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":392,"ts":1714749620.137,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":393,"ts":1714749620.253,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 ^&values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":394,"ts":1714749620.515,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 ^&values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 ^values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":395,"ts":1714749621.011,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 ^values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":396,"ts":1714749621.388,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 &values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":397,"ts":1714749621.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 &values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 &&values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":398,"ts":1714749621.834,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 &&values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":399,"ts":1714749621.894,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values.\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":400,"ts":1714749624.895,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values.\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":401,"ts":1714749625.455,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":402,"ts":1714749625.588,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":403,"ts":1714749625.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1]\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":404,"ts":1714749625.826,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1]\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":405,"ts":1714749626.086,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].t\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":406,"ts":1714749626.548,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].t\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].typ\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":407,"ts":1714749626.646,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].typ\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":408,"ts":1714749626.702,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":409,"ts":1714749626.924,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":410,"ts":1714749627.022,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type =\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type ==\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":411,"ts":1714749627.16,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type ==\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type ===\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":412,"ts":1714749627.286,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type ===\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":413,"ts":1714749627.419,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === '\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":414,"ts":1714749627.538,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === '\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'a\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":415,"ts":1714749627.764,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'a\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'ar\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":416,"ts":1714749627.889,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'ar\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'arra\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":417,"ts":1714749628.036,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'arra\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":418,"ts":1714749628.133,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array'\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":419,"ts":1714749628.517,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array'\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array')\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":420,"ts":1714749629.851,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array')\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":421,"ts":1714749630.015,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":422,"ts":1714749630.123,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":423,"ts":1714749630.406,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n     \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":424,"ts":1714749630.964,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n     \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":425,"ts":1714749631.091,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    {\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":426,"ts":1714749631.263,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    {\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":427,"ts":1714749631.954,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    \n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":428,"ts":1714749632.158,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":429,"ts":1714749633.728,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      re\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":430,"ts":1714749669.555,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      re\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      ret\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":431,"ts":1714749669.75,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      ret\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      retur\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":432,"ts":1714749669.837,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      retur\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":433,"ts":1714749669.918,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":434,"ts":1714749670.107,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":435,"ts":1714749670.241,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {t\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":436,"ts":1714749670.412,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {t\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {typ\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":437,"ts":1714749670.523,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {typ\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":438,"ts":1714749670.591,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type:\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":439,"ts":1714749670.783,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type:\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":440,"ts":1714749670.855,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: '\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":441,"ts":1714749671.007,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: '\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 't\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":442,"ts":1714749671.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 't\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tc\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":443,"ts":1714749671.315,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tc\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":444,"ts":1714749671.402,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon'\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":445,"ts":1714749671.657,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon'\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon',\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":446,"ts":1714749671.74,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon',\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":447,"ts":1714749671.865,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":448,"ts":1714749672.008,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0:\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":449,"ts":1714749672.27,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0:\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":450,"ts":1714749672.366,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: '\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":451,"ts":1714749672.474,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: '\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":452,"ts":1714749674.095,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a f\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":453,"ts":1714749674.218,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a f\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a fun\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":454,"ts":1714749674.526,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a fun\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a func\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":455,"ts":1714749674.586,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a func\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a functi\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":456,"ts":1714749674.813,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a functi\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a functio\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":457,"ts":1714749674.89,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a functio\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":458,"ts":1714749675.023,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function',\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":459,"ts":1714749675.277,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function',\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":460,"ts":1714749675.44,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":461,"ts":1714749675.555,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":462,"ts":1714749675.846,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: \n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: no\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":463,"ts":1714749676.662,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: no\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":464,"ts":1714749676.773,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":465,"ts":1714749676.868,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.l\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":466,"ts":1714749677.134,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.l\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.loc\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":467,"ts":1714749677.284,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":998,"idx":212},{"type":"ns-top","idx":998},{"type":"rich-text","idx":997,"sel":null}]}],"prev":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.loc\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"meta":{},"metaPrev":{},"map":{"997":{"type":"raw-code","lang":"javascript","raw":"parseType = node => {\n  if (node.type === 'identifier') {\n    return {type: 'tcon', 0: node.text, 1: node.loc}\n  }\n  if (node.type === 'list') {\n    const values = filterBlanks(node.values)\n    if (!values.length) return {type: 'tcon', 0: '()', 1: node.loc}\n    if (values.length === 3 && values[0].type === 'identifier' && values[1].type === 'array') {\n      return {type: 'tcon', 0: 'a function', 1: node.loc}\n    }\n    let res = parseType(values[0])\n    for (let i=1;i<values.length; i++) {\n      res = {type: 'tapp', 0: res, 1: parseType(values[i]), 2: node.loc}\n    }\n    return res\n  }\n  throw new Error(`cant parse type ${node.type}`)\n}","loc":997}},"nsMap":{},"nsPrev":{},"id":468,"ts":1714749677.511,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":22,"idx":36},{"type":"ns-top","idx":22},{"type":"rich-text","idx":21,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":22,"idx":36},{"type":"ns-top","idx":22},{"type":"rich-text","idx":21,"sel":null}]}],"prev":{"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: got})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21}},"meta":{},"metaPrev":{},"map":{"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: in})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21}},"nsMap":{},"nsPrev":{},"id":469,"ts":1714750016.094,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":22,"idx":36},{"type":"ns-top","idx":22},{"type":"rich-text","idx":21,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":22,"idx":36},{"type":"ns-top","idx":22},{"type":"rich-text","idx":21,"sel":null}]}],"prev":{"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: in})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21}},"meta":{},"metaPrev":{},"map":{"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: ini})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21}},"nsMap":{},"nsPrev":{},"id":470,"ts":1714750016.205,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":22,"idx":36},{"type":"ns-top","idx":22},{"type":"rich-text","idx":21,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":22,"idx":36},{"type":"ns-top","idx":22},{"type":"rich-text","idx":21,"sel":null}]}],"prev":{"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: ini})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21}},"meta":{},"metaPrev":{},"map":{"21":{"type":"raw-code","lang":"javascript","raw":"evaluate = (node, scope) => {\n  switch (node.type) {\n    case 'eprim':\n      return node[0][0]\n    case 'estr':\n      return slash(node[0]) + unwrapArray(node[1]).map(({0: exp, 1: suf}) => evaluate(exp, scope) + slash(suf)).join('')\n    case 'evar':\n      var name = sanitize(node[0])\n      if (!Object.hasOwn(scope, name)) {\n        throw new Error(`Unknown vbl: ${name}. ${Object.keys(scope).join(', ')}`)\n      }\n      return scope[name]\n    case 'elambda':\n      return v => evaluate(node[1], {...scope, [sanitize(node[0])]: v})\n    case 'eapp':\n      return evaluate(node[0], scope)(evaluate(node[1], scope))\n    case 'elet':\n      const init = evaluate(node[1], scope)\n      return evaluate(node[2], {...scope, [sanitize(node[0])]: init})\n    case 'ematch':\n      const target = evaluate(node[0], scope)\n      for (let {0: pat, 1: body} of unwrapArray(node[1])) {\n        const got = evalPat(pat, target)\n        if (got) {\n          return evaluate(body, {...scope, ...got})\n        }\n      }\n      throw new Error(`match failed (${node[2]}): ${JSON.stringify(target)}`)\n    case 'equot':\n      return node[0]\n  }\n  throw new Error(`cant evaluatoe ${node.type}`)\n}","loc":21}},"nsMap":{},"nsPrev":{},"id":471,"ts":1714750016.396,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":472,"ts":1714750180.241,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    ca\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":473,"ts":1714750181.139,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    ca\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    cas\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":474,"ts":1714750181.209,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    cas\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":475,"ts":1714750181.434,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case '\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":476,"ts":1714750181.526,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case '\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'p\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":477,"ts":1714750181.805,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'p\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pt\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":478,"ts":1714750181.951,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pt\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'p\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":479,"ts":1714750182.503,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'p\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":480,"ts":1714750182.654,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr'\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":481,"ts":1714750182.785,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr'\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr':\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":482,"ts":1714750183.149,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr':\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":483,"ts":1714750183.188,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': re\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":484,"ts":1714750183.5,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': re\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': ret\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":485,"ts":1714750183.7,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': ret\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': retur\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":486,"ts":1714750183.803,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': retur\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":487,"ts":1714750183.989,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":488,"ts":1714750184.1,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":489,"ts":1714750184.443,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":490,"ts":1714750184.576,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v =\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":491,"ts":1714750184.683,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v =\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v ==\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":492,"ts":1714750184.955,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v ==\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v ===\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":493,"ts":1714750185.252,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v ===\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":494,"ts":1714750188.384,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === \n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === no\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":495,"ts":1714750188.529,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === no\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === nod\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":496,"ts":1714750188.574,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === nod\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":497,"ts":1714750188.641,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node[\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":498,"ts":1714750188.852,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":287,"idx":36},{"type":"ns-top","idx":287},{"type":"rich-text","idx":286,"sel":null}]}],"prev":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node[\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"meta":{},"metaPrev":{},"map":{"286":{"type":"raw-code","lang":"javascript","raw":"evalPat = (node, v) => {\n  switch (node.type) {\n    case 'pany': return {}\n    case 'pprim': return v === node[0][0] ? {} : null\n    case 'pstr': return v === node[0]\n    case 'pvar':\n      return {[sanitize(node[0])]: v}\n    case 'pcon':\n      if (v.type === node[0]) {\n        const args = unwrapArray(node[1])\n        const scope = {}\n        for (let i=0; i<args.length; i++) {\n          const sub = evalPat(args[i], v[i])\n          if (!sub) return\n          Object.assign(scope, sub)\n        }\n        return scope\n      }\n  }\n}       ","loc":286}},"nsMap":{},"nsPrev":{},"id":499,"ts":1714750189.094,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns-top","idx":876},{"idx":877,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns-top","idx":876},{"idx":877,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":false}},"nsPrev":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":true}},"id":500,"ts":1714753221.634,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns-top","idx":878},{"idx":879,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns-top","idx":878},{"idx":991,"type":"spread-contents"},{"idx":879,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"878":{"type":"normal","id":878,"top":879,"children":[]}},"nsPrev":{"878":{"type":"normal","id":878,"top":991,"children":[]}},"id":501,"ts":1714753444.781,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":992,"type":"spread-contents"},{"idx":893,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"892":{"type":"normal","id":892,"top":893,"children":[]}},"nsPrev":{"892":{"type":"normal","id":892,"top":992,"children":[]}},"id":502,"ts":1714753471.267,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":924,"idx":876},{"type":"ns-top","idx":924},{"idx":925,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":924,"idx":876},{"type":"ns-top","idx":924},{"idx":993,"type":"spread-contents"},{"idx":925,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"924":{"type":"normal","id":924,"top":925,"children":[]}},"nsPrev":{"924":{"type":"normal","id":924,"top":993,"children":[]}},"id":503,"ts":1714753473.6,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":934,"idx":876},{"type":"ns-top","idx":934},{"idx":935,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":934,"idx":876},{"type":"ns-top","idx":934},{"idx":994,"type":"spread-contents"},{"idx":935,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"934":{"type":"normal","id":934,"top":935,"children":[]}},"nsPrev":{"934":{"type":"normal","id":934,"top":994,"children":[]}},"id":504,"ts":1714753475.439,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":955,"idx":876},{"type":"ns-top","idx":955},{"idx":956,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":955,"idx":876},{"type":"ns-top","idx":955},{"idx":995,"type":"spread-contents"},{"idx":956,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"955":{"type":"normal","id":955,"top":956,"children":[]}},"nsPrev":{"955":{"type":"normal","id":955,"top":995,"children":[]}},"id":505,"ts":1714753477.587,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":969,"idx":876},{"type":"ns-top","idx":969},{"idx":970,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":969,"idx":876},{"type":"ns-top","idx":969},{"idx":996,"type":"spread-contents"},{"idx":970,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"969":{"type":"normal","id":969,"top":970,"children":[]}},"nsPrev":{"969":{"type":"normal","id":969,"top":996,"children":[]}},"id":506,"ts":1714753479.279,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns-top","idx":876},{"idx":877,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns-top","idx":876},{"idx":877,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":true}},"nsPrev":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":false}},"id":507,"ts":1714753481.236,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":32,"idx":216},{"type":"ns-top","idx":32},{"idx":31,"type":"child","at":0},{"type":"rich-text","idx":40,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":32,"idx":216},{"type":"ns-top","idx":32},{"idx":31,"type":"child","at":0},{"idx":40,"type":"subtext","at":2}]}],"prev":{"40":{"type":"identifier","text":"parse","loc":40}},"meta":{},"metaPrev":{},"map":{"40":{"type":"raw-code","lang":"javascript","raw":"// write some code","loc":40}},"nsMap":{},"nsPrev":{},"id":508,"ts":1714753490.492,"libraryRoot":""},{"id":509,"meta":{},"metaPrev":{},"revert":508,"prev":{"40":{"type":"raw-code","lang":"javascript","raw":"// write some code","loc":40}},"map":{"40":{"type":"identifier","text":"parse","loc":40}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":32,"idx":216},{"type":"ns-top","idx":32},{"idx":31,"type":"child","at":0},{"idx":40,"type":"subtext","at":2}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":32,"idx":216},{"type":"ns-top","idx":32},{"idx":31,"type":"child","at":0},{"type":"rich-text","idx":40,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714753493.654,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":32,"idx":216},{"type":"ns-top","idx":32},{"idx":31,"type":"child","at":0},{"type":"rich-text","idx":40,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":32,"idx":216},{"type":"ns-top","idx":32},{"idx":31,"type":"child","at":0},{"idx":40,"type":"subtext","at":2}]}],"prev":{"40":{"type":"identifier","text":"parse","loc":40}},"meta":{},"metaPrev":{},"map":{"40":{"type":"raw-code","lang":"javascript","raw":"parse","loc":40}},"nsMap":{},"nsPrev":{},"id":510,"ts":1714753586.846,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":797,"idx":216},{"type":"ns-top","idx":797},{"idx":796,"type":"child","at":0},{"type":"rich-text","idx":798,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":797,"idx":216},{"type":"ns-top","idx":797},{"idx":796,"type":"child","at":0},{"idx":798,"type":"subtext","at":1}]}],"prev":{"798":{"type":"identifier","text":"parse","loc":798}},"meta":{},"metaPrev":{},"map":{"798":{"type":"raw-code","lang":"javascript","raw":"parse","loc":798}},"nsMap":{},"nsPrev":{},"id":511,"ts":1714753590.3,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":62,"idx":216},{"type":"ns-top","idx":62},{"idx":61,"type":"child","at":0},{"type":"rich-text","idx":63,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":62,"idx":216},{"type":"ns-top","idx":62},{"idx":61,"type":"child","at":0},{"idx":63,"type":"subtext","at":1}]}],"prev":{"63":{"type":"identifier","text":"parse","loc":63}},"meta":{},"metaPrev":{},"map":{"63":{"type":"raw-code","lang":"javascript","raw":"parse","loc":63}},"nsMap":{},"nsPrev":{},"id":512,"ts":1714753593.248,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":47,"idx":216},{"type":"ns-top","idx":47},{"idx":46,"type":"child","at":0},{"type":"rich-text","idx":48,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":47,"idx":216},{"type":"ns-top","idx":47},{"idx":46,"type":"child","at":0},{"idx":48,"type":"subtext","at":1}]}],"prev":{"48":{"type":"identifier","text":"parse","loc":48}},"meta":{},"metaPrev":{},"map":{"48":{"type":"raw-code","lang":"javascript","raw":"parse","loc":48}},"nsMap":{},"nsPrev":{},"id":513,"ts":1714753597.27,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":51,"idx":216},{"type":"ns-top","idx":51},{"idx":50,"type":"child","at":0},{"type":"rich-text","idx":52,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":51,"idx":216},{"type":"ns-top","idx":51},{"idx":50,"type":"child","at":0},{"idx":52,"type":"subtext","at":4}]}],"prev":{"52":{"type":"identifier","text":"parse","loc":52}},"meta":{},"metaPrev":{},"map":{"52":{"type":"raw-code","lang":"javascript","raw":"parse","loc":52}},"nsMap":{},"nsPrev":{},"id":514,"ts":1714753599.452,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":1004,"idx":36},{"type":"ns-top","idx":1004},{"idx":1003,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":1004,"idx":36},{"type":"ns-top","idx":1004},{"idx":1003,"type":"end"}]}],"prev":{"1003":{"type":"raw-code","lang":"javascript","raw":"constrFn('hi', arr([1, 2]))(101)(11)","loc":1003}},"meta":{},"metaPrev":{},"map":{"1003":{"type":"blank","loc":1003}},"nsMap":{"1004":{"type":"normal","top":1003,"children":[],"id":1004}},"nsPrev":{"1004":{"type":"normal","top":1003,"children":[],"id":1004}},"id":515,"ts":1714753631.006,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":423,"idx":36},{"type":"ns-top","idx":423},{"idx":422,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":1004,"idx":36},{"type":"ns-top","idx":1004},{"idx":1003,"type":"start"}]}],"prev":{"1003":{"type":"blank","loc":1003}},"meta":{},"metaPrev":{},"map":{"1003":null},"nsMap":{"36":{"type":"normal","top":35,"children":[421,423,22,287,276,873,370,336,456],"id":36,"collapsed":false},"1004":null},"nsPrev":{"36":{"type":"normal","top":35,"children":[421,423,1004,22,287,276,873,370,336,456],"id":36,"collapsed":false},"1004":{"type":"normal","top":1003,"children":[],"id":1004}},"id":516,"ts":1714753631.255,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":755,"idx":9},{"type":"ns","idx":755},{"type":"ns-top","idx":807},{"type":"start","idx":806}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":807,"idx":9},{"type":"ns-top","idx":807},{"idx":806,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"9":{"type":"normal","top":8,"children":[594,809,811,813,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[807],"id":755}},"nsPrev":{"9":{"type":"normal","top":8,"children":[594,809,811,813,755,807,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[],"id":755}},"id":517,"ts":1714753677.122,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":755,"idx":9},{"type":"ns","child":807,"idx":755},{"type":"ns-top","idx":811},{"type":"start","idx":810}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":811,"idx":9},{"type":"ns-top","idx":811},{"idx":810,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"9":{"type":"normal","top":8,"children":[594,809,813,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[811,807],"id":755}},"nsPrev":{"9":{"type":"normal","top":8,"children":[594,809,811,813,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[807],"id":755}},"id":518,"ts":1714753681.006,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":755,"idx":9},{"type":"ns","child":811,"idx":755},{"type":"ns-top","idx":813},{"type":"start","idx":812}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":813,"idx":9},{"type":"ns-top","idx":813},{"idx":812,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"9":{"type":"normal","top":8,"children":[594,809,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[811,813,807],"id":755}},"nsPrev":{"9":{"type":"normal","top":8,"children":[594,809,813,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[811,807],"id":755}},"id":519,"ts":1714753682.907,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":755,"idx":9},{"type":"ns","idx":755,"child":811},{"type":"ns-top","idx":809},{"type":"start","idx":808}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":809,"idx":9},{"type":"ns-top","idx":809},{"idx":808,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"9":{"type":"normal","top":8,"children":[594,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[809,811,813,807],"id":755}},"nsPrev":{"9":{"type":"normal","top":8,"children":[594,809,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"755":{"type":"normal","top":754,"children":[811,813,807],"id":755}},"id":520,"ts":1714753685.639,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":755,"idx":9},{"type":"ns-top","idx":755},{"idx":754,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":755,"idx":9},{"type":"ns-top","idx":755},{"idx":754,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"755":{"type":"normal","top":754,"children":[809,811,813,807],"id":755,"collapsed":true}},"nsPrev":{"755":{"type":"normal","top":754,"children":[809,811,813,807],"id":755}},"id":521,"ts":1714753687.24,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":739,"idx":9},{"type":"ns","child":741,"idx":739},{"type":"ns-top","idx":741},{"idx":740,"type":"child","at":0},{"type":"rich-text","idx":742,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":9,"idx":0},{"type":"ns","child":739,"idx":9},{"type":"ns","child":741,"idx":739},{"type":"ns-top","idx":741},{"idx":740,"type":"child","at":0},{"idx":742,"type":"subtext","at":13}]}],"prev":{"742":{"type":"identifier","text":"testCompileStmt","loc":742}},"meta":{},"metaPrev":{},"map":{"742":{"type":"raw-code","lang":"javascript","raw":"testCompileStmt","loc":742}},"nsMap":{},"nsPrev":{},"id":522,"ts":1714753696.083,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns-top","idx":11},{"idx":10,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns-top","idx":11},{"idx":10,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"11":{"type":"normal","top":10,"children":[567,569],"id":11,"collapsed":false}},"nsPrev":{"11":{"type":"normal","top":10,"children":[567,569],"id":11,"collapsed":true}},"id":523,"ts":1714753704.274,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":569,"idx":11},{"type":"ns-top","idx":569},{"idx":568,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":569,"idx":11},{"type":"ns-top","idx":569},{"idx":568,"type":"end"}]}],"prev":{"568":{"type":"raw-code","lang":"javascript","raw":"compilePat_ = (node, target, body) => {\n  switch (node.type) {\n    case 'pany':\n      return body\n    case 'pvar':\n      return `{const ${sanitize(node[0])} = ${target};\\n${body}}`\n    case 'pprim':\n      return `if (${target} === ${node[0][0]}) {${body}}`\n    case 'pcon':\n      const args = unwrapArray(node[1])\n  }\n}","loc":568}},"meta":{},"metaPrev":{},"map":{"568":{"type":"blank","loc":568}},"nsMap":{"569":{"type":"normal","top":568,"children":[],"id":569}},"nsPrev":{"569":{"type":"normal","top":568,"children":[],"id":569}},"id":524,"ts":1714753709.301,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":567,"idx":11},{"type":"ns-top","idx":567},{"idx":566,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":569,"idx":11},{"type":"ns-top","idx":569},{"idx":568,"type":"start"}]}],"prev":{"568":{"type":"blank","loc":568}},"meta":{},"metaPrev":{},"map":{"568":null},"nsMap":{"11":{"type":"normal","top":10,"children":[567],"id":11,"collapsed":false},"569":null},"nsPrev":{"11":{"type":"normal","top":10,"children":[567,569],"id":11,"collapsed":false},"569":{"type":"normal","top":568,"children":[],"id":569}},"id":525,"ts":1714753709.861,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":567,"idx":11},{"type":"ns-top","idx":567},{"idx":566,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":567,"idx":11},{"type":"ns-top","idx":567},{"idx":566,"type":"end"}]}],"prev":{"566":{"type":"raw-code","lang":"javascript","raw":"compile_ = node => {\n  switch (node.type) {\n    case 'eprim': return '' + node[0][0]\n    case 'estr': return `\\`${unslash(node[0])}${unwrapArray(node[1]).map(\n      ({0: expr, 1: suf}) => `\\${${compile(expr)}}${unslash(suf)}\\``\n    ).join('\\n')}`\n    case 'evar': return sanitize(node[0])\n    case 'elambda':\n      return `(${patArgs(node[0])}) => ${compile(node[1])}`\n    case 'eapp':\n      return `(${compile(node[0])})(${compile(node[1])})`\n    case 'elet':\n      return `((${patArgs(node[0])}) => ${compile(node[2])})(${compile(node[1])})`\n    case 'ematch':\n      return `(($target) => {${unwrapArray(node[1]).map(({0: pat, 1: body}) => compilePat(pat, '$target', 'return ' + compile(body))).join('\\n')})(${compile(node[0])})`\n  }\n}","loc":566}},"meta":{},"metaPrev":{},"map":{"566":{"type":"blank","loc":566}},"nsMap":{"567":{"type":"normal","top":566,"children":[],"id":567,"collapsed":false}},"nsPrev":{"567":{"type":"normal","top":566,"children":[],"id":567,"collapsed":false}},"id":526,"ts":1714753710.267,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns-top","idx":598},{"idx":597,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns","child":567,"idx":11},{"type":"ns-top","idx":567},{"idx":566,"type":"start"}]}],"prev":{"566":{"type":"blank","loc":566}},"meta":{},"metaPrev":{},"map":{"566":null},"nsMap":{"11":{"type":"normal","top":10,"children":[],"id":11,"collapsed":false},"567":null},"nsPrev":{"11":{"type":"normal","top":10,"children":[567],"id":11,"collapsed":false},"567":{"type":"normal","top":566,"children":[],"id":567,"collapsed":false}},"id":527,"ts":1714753710.691,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns-top","idx":11},{"idx":10,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns-top","idx":11},{"idx":10,"type":"end"}]}],"prev":{"10":{"type":"rich-text","contents":[{"id":"9ce7f4f1-7ee8-47c2-bd25-480e7a33babf","type":"paragraph","props":{"textColor":"default","backgroundColor":"default","textAlignment":"left"},"content":[{"type":"text","text":"Compile to js","styles":{"strike":true}}],"children":[]}],"loc":10}},"meta":{},"metaPrev":{},"map":{"10":{"type":"blank","loc":10}},"nsMap":{"11":{"type":"normal","top":10,"children":[],"id":11,"collapsed":false}},"nsPrev":{"11":{"type":"normal","top":10,"children":[],"id":11,"collapsed":false}},"id":528,"ts":1714753714.17,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns-top","idx":598},{"idx":597,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":11,"idx":0},{"type":"ns-top","idx":11},{"idx":10,"type":"start"}]}],"prev":{"10":{"type":"blank","loc":10}},"meta":{},"metaPrev":{},"map":{"10":null},"nsMap":{"0":{"id":0,"top":-1,"children":[1,3,214,876,212,36,598,9,575],"type":"normal"},"11":null},"nsPrev":{"0":{"id":0,"top":-1,"children":[1,3,214,876,212,36,598,11,9,575],"type":"normal"},"11":{"type":"normal","top":10,"children":[],"id":11,"collapsed":false}},"id":529,"ts":1714753714.624,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"idx":777,"type":"subtext","at":6}]}],"prev":{"777":{"type":"identifier","text":"parsePat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"nsMap":{},"nsPrev":{},"id":530,"ts":1714753814.133,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parse\nPat","loc":777}},"nsMap":{},"nsPrev":{},"id":531,"ts":1714754121.087,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parse\nPat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"nsMap":{},"nsPrev":{},"id":532,"ts":1714754123.944,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parseP\nat","loc":777}},"nsMap":{},"nsPrev":{},"id":533,"ts":1714754140.422,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parseP\nat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"nsMap":{},"nsPrev":{},"id":534,"ts":1714754266.481,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parsesPat","loc":777}},"nsMap":{},"nsPrev":{},"id":535,"ts":1714754268.333,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parsesPat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"nsMap":{},"nsPrev":{},"id":536,"ts":1714754269.047,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parse\nPat","loc":777}},"nsMap":{},"nsPrev":{},"id":537,"ts":1714754269.768,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":218,"idx":212},{"type":"ns","child":776,"idx":218},{"type":"ns-top","idx":776},{"idx":775,"type":"child","at":0},{"type":"rich-text","idx":777,"sel":null}]}],"prev":{"777":{"type":"raw-code","lang":"javascript","raw":"parse\nPat","loc":777}},"meta":{},"metaPrev":{},"map":{"777":{"type":"raw-code","lang":"javascript","raw":"parsePat","loc":777}},"nsMap":{},"nsPrev":{},"id":538,"ts":1714754271.902,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prev":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(names(parseStmt(v)))","loc":691}},"meta":{},"metaPrev":{},"map":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\n  names(parseStmt(v)))","loc":691}},"nsMap":{},"nsPrev":{},"id":539,"ts":1714754334.024,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prev":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\n  names(parseStmt(v)))","loc":691}},"meta":{},"metaPrev":{},"map":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\n names(parseStmt(v)))","loc":691}},"nsMap":{},"nsPrev":{},"id":540,"ts":1714754337.464,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prev":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\n names(parseStmt(v)))","loc":691}},"meta":{},"metaPrev":{},"map":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\nnames(parseStmt(v)))","loc":691}},"nsMap":{},"nsPrev":{},"id":541,"ts":1714754337.698,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prev":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\nnames(parseStmt(v)))","loc":691}},"meta":{},"metaPrev":{},"map":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(names(parseStmt(v)))","loc":691}},"nsMap":{},"nsPrev":{},"id":542,"ts":1714754337.987,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prev":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(names(parseStmt(v)))","loc":691}},"meta":{},"metaPrev":{},"map":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\n  names(parseStmt(v)))","loc":691}},"nsMap":{},"nsPrev":{},"id":543,"ts":1714754338.88,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":692,"idx":598},{"type":"ns-top","idx":692},{"type":"rich-text","idx":691,"sel":null}]}],"prev":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(\n  names(parseStmt(v)))","loc":691}},"meta":{},"metaPrev":{},"map":{"691":{"type":"raw-code","lang":"javascript","raw":"testNames = v => valueToString(names(parseStmt(v)))","loc":691}},"nsMap":{},"nsPrev":{},"id":544,"ts":1714754339.709,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"214":{"type":"normal","top":213,"children":[28,30,26,99,291,293,112,58,71,138,150],"id":214,"collapsed":false}},"nsPrev":{"214":{"type":"normal","top":213,"children":[28,30,26,99,291,293,112,58,71,138,150],"id":214,"collapsed":true}},"id":545,"ts":1714754535.465,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":28,"idx":214},{"type":"ns-top","idx":26},{"type":"start","idx":25}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":26,"idx":214},{"type":"ns-top","idx":26},{"idx":25,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"214":{"type":"normal","top":213,"children":[26,28,30,99,291,293,112,58,71,138,150],"id":214,"collapsed":false}},"nsPrev":{"214":{"type":"normal","top":213,"children":[28,30,26,99,291,293,112,58,71,138,150],"id":214,"collapsed":false}},"id":546,"ts":1714754540.849,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":99,"idx":214},{"type":"ns-top","idx":99},{"idx":98,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":99,"idx":214},{"type":"ns-top","idx":99},{"idx":98,"type":"end"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"99":{"type":"normal","top":98,"children":[110],"id":99,"collapsed":true}},"nsPrev":{"99":{"type":"normal","top":98,"children":[110],"id":99}},"id":547,"ts":1714754561.999,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":291,"idx":214},{"type":"ns-top","idx":291},{"idx":290,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":291,"idx":214},{"type":"ns-top","idx":291},{"idx":290,"type":"end"}]}],"prev":{"290":{"type":"raw-code","lang":"javascript","raw":"foldlArr = (i, v, f) => v.type === 'nil' ? i : foldlArr(f(i, v[0]), v[1], f)","loc":290}},"meta":{},"metaPrev":{},"map":{"290":{"type":"blank","loc":290}},"nsMap":{"291":{"type":"normal","top":290,"children":[],"id":291}},"nsPrev":{"291":{"type":"normal","top":290,"children":[],"id":291}},"id":548,"ts":1714754620.147,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":99,"idx":214},{"type":"ns-top","idx":99},{"idx":98,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns","child":291,"idx":214},{"type":"ns-top","idx":291},{"idx":290,"type":"start"}]}],"prev":{"290":{"type":"blank","loc":290}},"meta":{},"metaPrev":{},"map":{"290":null},"nsMap":{"214":{"type":"normal","top":213,"children":[26,28,30,99,293,112,58,71,138,150],"id":214,"collapsed":false},"291":null},"nsPrev":{"214":{"type":"normal","top":213,"children":[26,28,30,99,291,293,112,58,71,138,150],"id":214,"collapsed":false},"291":{"type":"normal","top":290,"children":[],"id":291}},"id":549,"ts":1714754620.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":2,"idx":82},{"idx":127,"type":"child","at":1},{"idx":134,"type":"child","at":0},{"idx":135,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":2,"idx":82},{"idx":127,"type":"child","at":1},{"idx":134,"type":"child","at":0},{"idx":135,"type":"subtext","at":1}]}],"prev":{"135":{"type":"identifier","text":"@","loc":135}},"meta":{},"metaPrev":{},"map":{"135":{"type":"blank","loc":135}},"nsMap":{},"nsPrev":{},"id":550,"ts":1714754629.856,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":2,"idx":82},{"idx":127,"type":"child","at":1},{"idx":135,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":2,"idx":82},{"idx":127,"type":"child","at":1},{"idx":134,"type":"child","at":0},{"idx":135,"type":"subtext","at":0}]}],"prev":{"127":{"type":"list","values":[128,134,130],"loc":127},"134":{"type":"list","values":[135,129],"loc":134}},"meta":{},"metaPrev":{},"map":{"127":{"type":"list","values":[128,135,129,130],"loc":127},"134":null},"nsMap":{},"nsPrev":{},"id":551,"ts":1714754630.58,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":2,"idx":82},{"idx":127,"type":"child","at":0},{"idx":128,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":2,"idx":82},{"idx":127,"type":"child","at":1},{"idx":135,"type":"subtext","at":0}]}],"prev":{"127":{"type":"list","values":[128,135,129,130],"loc":127},"135":{"type":"blank","loc":135}},"meta":{},"metaPrev":{},"map":{"127":{"type":"list","values":[128,129,130],"loc":127},"135":null},"nsMap":{},"nsPrev":{},"id":552,"ts":1714754631.215,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":88,"type":"child","at":0},{"idx":87,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":88,"type":"child","at":0},{"idx":87,"type":"subtext","at":1}]}],"prev":{"87":{"type":"identifier","text":"@","loc":87}},"meta":{},"metaPrev":{},"map":{"87":{"type":"blank","loc":87}},"nsMap":{},"nsPrev":{},"id":553,"ts":1714754633.223,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":87,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":88,"type":"child","at":0},{"idx":87,"type":"subtext","at":0}]}],"prev":{"83":{"type":"list","values":[84,88,86],"loc":83},"88":{"type":"list","values":[87,89],"loc":88}},"meta":{},"metaPrev":{},"map":{"83":{"type":"list","values":[84,87,89,86],"loc":83},"88":null},"nsMap":{},"nsPrev":{},"id":554,"ts":1714754633.558,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":0},{"idx":84,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":87,"type":"subtext","at":0}]}],"prev":{"83":{"type":"list","values":[84,87,89,86],"loc":83},"87":{"type":"blank","loc":87}},"meta":{},"metaPrev":{},"map":{"83":{"type":"list","values":[84,89,86],"loc":83},"87":null},"nsMap":{},"nsPrev":{},"id":555,"ts":1714754633.966,"libraryRoot":""},{"id":556,"meta":{},"metaPrev":{},"revert":555,"prev":{"83":{"type":"list","values":[84,89,86],"loc":83},"87":null},"map":{"83":{"type":"list","values":[84,87,89,86],"loc":83},"87":{"type":"blank","loc":87}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":87,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":0},{"idx":84,"type":"end"}]}],"nsMap":{},"nsPrev":{},"ts":1714754635.33,"libraryRoot":""},{"id":557,"meta":{},"metaPrev":{},"revert":554,"prev":{"83":{"type":"list","values":[84,87,89,86],"loc":83},"88":null},"map":{"83":{"type":"list","values":[84,88,86],"loc":83},"88":{"type":"list","values":[87,89],"loc":88}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":88,"type":"child","at":0},{"idx":87,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":87,"type":"subtext","at":0}]}],"nsMap":{},"nsPrev":{},"ts":1714754635.711,"libraryRoot":""},{"id":558,"meta":{},"metaPrev":{},"revert":553,"prev":{"87":{"type":"blank","loc":87}},"map":{"87":{"type":"identifier","text":"@","loc":87}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":88,"type":"child","at":0},{"idx":87,"type":"subtext","at":1}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":2},{"type":"child","at":0,"idx":82},{"idx":83,"type":"child","at":1},{"idx":88,"type":"child","at":0},{"idx":87,"type":"subtext","at":0}]}],"nsMap":{},"nsPrev":{},"ts":1714754638.81,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"type":"rich-text","idx":81,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"idx":81,"type":"subtext","at":4}]}],"prev":{"81":{"type":"identifier","text":"test","loc":81}},"meta":{},"metaPrev":{},"map":{"81":{"type":"raw-code","lang":"javascript","raw":"test","loc":81}},"nsMap":{},"nsPrev":{},"id":559,"ts":1714754683.764,"libraryRoot":""},{"id":560,"meta":{},"metaPrev":{},"revert":559,"prev":{"81":{"type":"raw-code","lang":"javascript","raw":"test","loc":81}},"map":{"81":{"type":"identifier","text":"test","loc":81}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"idx":81,"type":"subtext","at":4}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"type":"rich-text","idx":81,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754716.801,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"type":"rich-text","idx":81,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"idx":81,"type":"subtext","at":1}]}],"prev":{"81":{"type":"identifier","text":"test","loc":81}},"meta":{},"metaPrev":{},"map":{"81":{"type":"raw-code","lang":"javascript","raw":"test","loc":81}},"nsMap":{},"nsPrev":{},"id":561,"ts":1714754815.436,"libraryRoot":""},{"at":[{"start":[{"type":"card","card":0,"idx":-1},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":230,"idx":220},{"type":"ns-top","idx":230}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":216,"idx":212},{"type":"ns","child":79,"idx":216},{"type":"ns-top","idx":79},{"idx":78,"type":"child","at":1},{"type":"rich-text","idx":81,"sel":null}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"220":{"type":"normal","top":219,"children":[222,226,228,248,230],"id":220,"collapsed":false}},"nsPrev":{"220":{"type":"normal","top":219,"children":[222,226,228,248,230],"id":220,"collapsed":true}},"id":562,"ts":1714754817.319,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":230,"idx":220},{"type":"ns-top","idx":230},{"idx":229,"type":"child","at":1},{"type":"rich-text","idx":232,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":230,"idx":220},{"type":"ns-top","idx":230},{"idx":229,"type":"child","at":1},{"idx":232,"type":"subtext","at":5}]}],"prev":{"232":{"type":"identifier","text":"testStmt","loc":232}},"meta":{},"metaPrev":{},"map":{"232":{"type":"raw-code","lang":"javascript","raw":"testStmt","loc":232}},"nsMap":{},"nsPrev":{},"id":563,"ts":1714754821.434,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":248,"idx":220},{"type":"ns-top","idx":248},{"idx":249,"type":"child","at":0},{"type":"rich-text","idx":247,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":212,"idx":0},{"type":"ns","child":220,"idx":212},{"type":"ns","child":248,"idx":220},{"type":"ns-top","idx":248},{"idx":249,"type":"child","at":0},{"idx":247,"type":"subtext","at":5}]}],"prev":{"247":{"type":"identifier","text":"testStmt","loc":247}},"meta":{},"metaPrev":{},"map":{"247":{"type":"raw-code","lang":"javascript","raw":"testStmt","loc":247}},"nsMap":{},"nsPrev":{},"id":564,"ts":1714754824.007,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":370,"idx":36},{"type":"ns-top","idx":370},{"idx":369,"type":"child","at":1},{"type":"rich-text","idx":372,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":370,"idx":36},{"type":"ns-top","idx":370},{"idx":369,"type":"child","at":1},{"idx":372,"type":"subtext","at":3}]}],"prev":{"372":{"type":"identifier","text":"run","loc":372}},"meta":{},"metaPrev":{},"map":{"372":{"type":"raw-code","lang":"javascript","raw":"run","loc":372}},"nsMap":{},"nsPrev":{},"id":565,"ts":1714754839.762,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":456,"idx":36},{"type":"ns-top","idx":456},{"idx":455,"type":"child","at":1},{"type":"rich-text","idx":458,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":36,"idx":0},{"type":"ns","child":456,"idx":36},{"type":"ns-top","idx":456},{"idx":455,"type":"child","at":1},{"idx":458,"type":"subtext","at":5}]}],"prev":{"458":{"type":"identifier","text":"stmts","loc":458}},"meta":{},"metaPrev":{},"map":{"458":{"type":"raw-code","lang":"javascript","raw":"stmts","loc":458}},"nsMap":{},"nsPrev":{},"id":566,"ts":1714754873.97,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":1},{"type":"rich-text","idx":615,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":1},{"idx":615,"type":"subtext","at":7}]}],"prev":{"615":{"type":"identifier","text":"testExt","loc":615}},"meta":{},"metaPrev":{},"map":{"615":{"type":"raw-code","lang":"javascript","raw":"testExt","loc":615}},"nsMap":{},"nsPrev":{},"id":567,"ts":1714754877.88,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":694,"idx":598},{"type":"ns-top","idx":694},{"idx":693,"type":"child","at":1},{"type":"rich-text","idx":697,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":694,"idx":598},{"type":"ns-top","idx":694},{"idx":693,"type":"child","at":1},{"idx":697,"type":"subtext","at":9}]}],"prev":{"697":{"type":"identifier","text":"testNames","loc":697}},"meta":{},"metaPrev":{},"map":{"697":{"type":"raw-code","lang":"javascript","raw":"testNames","loc":697}},"nsMap":{},"nsPrev":{},"id":568,"ts":1714754880.915,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"text","at":0},{"type":"rich-text","idx":630,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"text","at":0},{"idx":630,"type":"subtext","at":2}]}],"prev":{"630":{"type":"stringText","loc":630,"text":"[[\\\"lol\\\", (value), 620]]"}},"meta":{},"metaPrev":{},"map":{"630":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":630}},"nsMap":{},"nsPrev":{},"id":569,"ts":1714754928.363,"libraryRoot":""},{"id":570,"meta":{},"metaPrev":{},"revert":569,"prev":{"630":{"type":"raw-code","lang":"javascript","raw":"// some code","loc":630}},"map":{"630":{"type":"stringText","loc":630,"text":"[[\\\"lol\\\", (value), 620]]"}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"text","at":0},{"idx":630,"type":"subtext","at":2}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"text","at":0},{"type":"rich-text","idx":630,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754932.73,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"start"}]}],"prev":{"621":{"type":"string","first":630,"templates":[],"loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":571,"ts":1714754935.352,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":572,"ts":1714754938.429,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\\\", (value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":573,"ts":1714754939.523,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", (value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":574,"ts":1714754942.281,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":575,"ts":1714754942.579,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {tvalue), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":576,"ts":1714754942.811,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {tvalue), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {typvalue), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":577,"ts":1714754942.946,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {typvalue), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {typevalue), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":578,"ts":1714754943.001,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {typevalue), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type:value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":579,"ts":1714754943.216,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type:value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":580,"ts":1714754943.263,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":581,"ts":1714754943.637,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value, 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":582,"ts":1714754944.833,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value, 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":583,"ts":1714754945.362,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value'}, 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":584,"ts":1714754945.756,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value'}, 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":585,"ts":1714754966.416,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":586,"ts":1714754967.848,"libraryRoot":""},{"id":587,"meta":{},"metaPrev":{},"revert":586,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754969.085,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":588,"ts":1714754970.098,"libraryRoot":""},{"id":589,"meta":{},"metaPrev":{},"revert":588,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754970.516,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":590,"ts":1714754970.652,"libraryRoot":""},{"id":591,"meta":{},"metaPrev":{},"revert":590,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754971.064,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":592,"ts":1714754971.196,"libraryRoot":""},{"id":593,"meta":{},"metaPrev":{},"revert":592,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754971.648,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":594,"ts":1714754971.764,"libraryRoot":""},{"id":595,"meta":{},"metaPrev":{},"revert":594,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754972.239,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":596,"ts":1714754972.351,"libraryRoot":""},{"id":597,"meta":{},"metaPrev":{},"revert":596,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754972.909,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":598,"ts":1714754973.029,"libraryRoot":""},{"id":599,"meta":{},"metaPrev":{},"revert":598,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754973.551,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":600,"ts":1714754973.652,"libraryRoot":""},{"id":601,"meta":{},"metaPrev":{},"revert":600,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754974.098,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":602,"ts":1714754974.237,"libraryRoot":""},{"id":603,"meta":{},"metaPrev":{},"revert":602,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754974.687,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":604,"ts":1714754974.779,"libraryRoot":""},{"id":605,"meta":{},"metaPrev":{},"revert":604,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754975.162,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":606,"ts":1714754975.246,"libraryRoot":""},{"id":607,"meta":{},"metaPrev":{},"revert":606,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754975.853,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":608,"ts":1714754975.963,"libraryRoot":""},{"id":609,"meta":{},"metaPrev":{},"revert":608,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754978.932,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":610,"ts":1714754979.14,"libraryRoot":""},{"id":611,"meta":{},"metaPrev":{},"revert":610,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754979.827,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":612,"ts":1714754980.098,"libraryRoot":""},{"id":613,"meta":{},"metaPrev":{},"revert":612,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754980.547,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":614,"ts":1714754980.697,"libraryRoot":""},{"id":615,"meta":{},"metaPrev":{},"revert":614,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754981.217,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":616,"ts":1714754981.338,"libraryRoot":""},{"id":617,"meta":{},"metaPrev":{},"revert":616,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754981.863,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":618,"ts":1714754981.962,"libraryRoot":""},{"id":619,"meta":{},"metaPrev":{},"revert":618,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754982.529,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":620,"ts":1714754982.631,"libraryRoot":""},{"id":621,"meta":{},"metaPrev":{},"revert":620,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754983.135,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":622,"ts":1714754983.229,"libraryRoot":""},{"id":623,"meta":{},"metaPrev":{},"revert":622,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754983.814,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":624,"ts":1714754983.92,"libraryRoot":""},{"id":625,"meta":{},"metaPrev":{},"revert":624,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754985.08,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":626,"ts":1714754985.177,"libraryRoot":""},{"id":627,"meta":{},"metaPrev":{},"revert":626,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754985.754,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":628,"ts":1714754985.891,"libraryRoot":""},{"id":629,"meta":{},"metaPrev":{},"revert":628,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754986.816,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":630,"ts":1714754986.95,"libraryRoot":""},{"id":631,"meta":{},"metaPrev":{},"revert":630,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754987.573,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":632,"ts":1714754987.702,"libraryRoot":""},{"id":633,"meta":{},"metaPrev":{},"revert":632,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714754988.3,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":634,"ts":1714754988.43,"libraryRoot":""},{"id":635,"meta":{},"metaPrev":{},"revert":634,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714755012.854,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":636,"ts":1714755013.257,"libraryRoot":""},{"id":637,"meta":{},"metaPrev":{},"revert":636,"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"nsMap":{},"nsPrev":{},"ts":1714755014.353,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"type":"rich-text","idx":621,"sel":null}]}],"prev":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\"lol\", {type: 'value', 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"nsMap":{},"nsPrev":{},"id":638,"ts":1714755015.057,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prev":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"raw-code","lang":"javascript","raw":"[[\\\"lol\\\", (value), 620]]","loc":621}},"meta":{},"metaPrev":{},"map":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"blank","loc":621}},"nsMap":{},"nsPrev":{},"id":639,"ts":1714755019.84,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"subtext","at":0}]}],"prev":{"621":{"type":"blank","loc":621},"1040":null},"meta":{},"metaPrev":{},"map":{"621":{"type":"string","first":1040,"templates":[],"loc":621},"1040":{"type":"stringText","loc":1040,"text":"[[\\\"lol\\\", (value), 620]]"}},"nsMap":{},"nsPrev":{},"id":640,"ts":1714755022.872,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prev":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => valueToString(externals(parseStmt(v)))","loc":607}},"meta":{},"metaPrev":{},"map":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607}},"nsMap":{},"nsPrev":{},"id":641,"ts":1714755050.731,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prev":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607}},"meta":{},"metaPrev":{},"map":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => (externals(parseStmt(v)))","loc":607}},"nsMap":{},"nsPrev":{},"id":642,"ts":1714755051.645,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prev":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => (externals(parseStmt(v)))","loc":607}},"meta":{},"metaPrev":{},"map":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => valueToString(externals(parseStmt(v)))","loc":607}},"nsMap":{},"nsPrev":{},"id":643,"ts":1714755057.431,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prev":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => valueToString(externals(parseStmt(v)))","loc":607}},"meta":{},"metaPrev":{},"map":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607}},"nsMap":{},"nsPrev":{},"id":644,"ts":1714755340.142,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prev":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607}},"meta":{},"metaPrev":{},"map":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => valueToString(externals(parseStmt(v)))","loc":607}},"nsMap":{},"nsPrev":{},"id":645,"ts":1714755342.725,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prev":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"string","first":1040,"templates":[],"loc":621},"1040":{"type":"stringText","loc":1040,"text":"[[\\\"lol\\\", (value), 620]]"}},"meta":{},"metaPrev":{},"map":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"blank","loc":621},"1040":null},"nsMap":{},"nsPrev":{},"id":646,"ts":1714755392.14,"libraryRoot":""},{"id":647,"meta":{},"metaPrev":{},"revert":646,"prev":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"blank","loc":621},"1040":null},"map":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"string","first":1040,"templates":[],"loc":621},"1040":{"type":"stringText","loc":1040,"text":"[[\\\"lol\\\", (value), 620]]"}},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"start"}]}],"nsMap":{},"nsPrev":{},"ts":1714755393.408,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"type":"rich-text","idx":607,"sel":null}],"end":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":608,"idx":598},{"type":"ns-top","idx":608},{"idx":607,"type":"start"}]}],"prev":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v => valueToString(externals(parseStmt(v)))","loc":607}},"meta":{},"metaPrev":{},"map":{"607":{"type":"raw-code","lang":"javascript","raw":"testExt = v =>(externals(parseStmt(v)))","loc":607}},"nsMap":{},"nsPrev":{},"id":648,"ts":1714755395.403,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prev":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"string","first":1040,"templates":[],"loc":621},"1040":{"type":"stringText","loc":1040,"text":"[[\\\"lol\\\", (value), 620]]"}},"meta":{},"metaPrev":{},"map":{"617":{"type":"list","values":[606,619,621],"loc":617},"621":{"type":"blank","loc":621},"1040":null},"nsMap":{},"nsPrev":{},"id":649,"ts":1714755398.883,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"subtext","at":0}]}],"prev":{"621":{"type":"blank","loc":621},"1041":null,"1042":null,"1043":null,"1044":null,"1045":null,"1046":null,"1047":null,"1048":null,"1049":null,"1050":null,"1051":null},"meta":{},"metaPrev":{},"map":{"621":{"type":"array","values":[1041],"loc":621},"1041":{"type":"array","values":[1042,1044,1045,1051],"loc":1041},"1042":{"type":"string","first":1043,"templates":[],"loc":1042},"1043":{"type":"stringText","loc":1043,"text":"lol"},"1044":{"type":"identifier","text":",","loc":1044},"1045":{"type":"record","values":[1048],"loc":1045},"1046":{"type":"string","first":1047,"templates":[],"loc":1046},"1047":{"type":"stringText","loc":1047,"text":"type"},"1048":{"type":"annot","target":1046,"annot":1049,"loc":1048},"1049":{"type":"string","first":1050,"templates":[],"loc":1049},"1050":{"type":"stringText","loc":1050,"text":"value"},"1051":{"type":"identifier","text":",620","loc":1051}},"nsMap":{},"nsPrev":{},"id":650,"ts":1714755401.598,"libraryRoot":""},{"id":651,"meta":{},"metaPrev":{},"revert":650,"prev":{"621":{"type":"array","values":[1041],"loc":621},"1041":{"type":"array","values":[1042,1044,1045,1051],"loc":1041},"1042":{"type":"string","first":1043,"templates":[],"loc":1042},"1043":{"type":"stringText","loc":1043,"text":"lol"},"1044":{"type":"identifier","text":",","loc":1044},"1045":{"type":"record","values":[1048],"loc":1045},"1046":{"type":"string","first":1047,"templates":[],"loc":1046},"1047":{"type":"stringText","loc":1047,"text":"type"},"1048":{"type":"annot","target":1046,"annot":1049,"loc":1048},"1049":{"type":"string","first":1050,"templates":[],"loc":1049},"1050":{"type":"stringText","loc":1050,"text":"value"},"1051":{"type":"identifier","text":",620","loc":1051}},"map":{"621":{"type":"blank","loc":621},"1041":null,"1042":null,"1043":null,"1044":null,"1045":null,"1046":null,"1047":null,"1048":null,"1049":null,"1050":null,"1051":null},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"nsMap":{},"nsPrev":{},"ts":1714755405.603,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"subtext","at":0}]}],"prev":{"621":{"type":"blank","loc":621},"1040":null,"1041":null,"1042":null,"1043":null,"1044":null,"1045":null,"1046":null,"1047":null,"1048":null,"1049":null,"1050":null},"meta":{},"metaPrev":{},"map":{"621":{"type":"array","values":[1040],"loc":621},"1040":{"type":"array","values":[1041,1043,1044,1050],"loc":1040},"1041":{"type":"string","first":1042,"templates":[],"loc":1041},"1042":{"type":"stringText","loc":1042,"text":"lol"},"1043":{"type":"identifier","text":",","loc":1043},"1044":{"type":"record","values":[1047],"loc":1044},"1045":{"type":"string","first":1046,"templates":[],"loc":1045},"1046":{"type":"stringText","loc":1046,"text":"type"},"1047":{"type":"annot","target":1045,"annot":1048,"loc":1047},"1048":{"type":"string","first":1049,"templates":[],"loc":1048},"1049":{"type":"stringText","loc":1049,"text":"value"},"1050":{"type":"identifier","text":",620","loc":1050}},"nsMap":{},"nsPrev":{},"id":652,"ts":1714755817.703,"libraryRoot":""},{"id":653,"meta":{},"metaPrev":{},"revert":652,"prev":{"621":{"type":"array","values":[1040],"loc":621},"1040":{"type":"array","values":[1041,1043,1044,1050],"loc":1040},"1041":{"type":"string","first":1042,"templates":[],"loc":1041},"1042":{"type":"stringText","loc":1042,"text":"lol"},"1043":{"type":"identifier","text":",","loc":1043},"1044":{"type":"record","values":[1047],"loc":1044},"1045":{"type":"string","first":1046,"templates":[],"loc":1045},"1046":{"type":"stringText","loc":1046,"text":"type"},"1047":{"type":"annot","target":1045,"annot":1048,"loc":1047},"1048":{"type":"string","first":1049,"templates":[],"loc":1048},"1049":{"type":"stringText","loc":1049,"text":"value"},"1050":{"type":"identifier","text":",620","loc":1050}},"map":{"621":{"type":"blank","loc":621},"1040":null,"1041":null,"1042":null,"1043":null,"1044":null,"1045":null,"1046":null,"1047":null,"1048":null,"1049":null,"1050":null},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"subtext","at":0}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"end"}]}],"nsMap":{},"nsPrev":{},"ts":1714755818.843,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":1040,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":0,"idx":616},{"idx":617,"type":"child","at":2},{"idx":621,"type":"subtext","at":0}]}],"prev":{"617":{"type":"list","values":[606,619,621],"loc":617},"1040":null},"meta":{},"metaPrev":{},"map":{"617":{"type":"list","values":[606,619,1040],"loc":617},"1040":{"type":"raw-code","lang":"javascript","loc":1040,"raw":"[[\"lol\",{\"type\":\"value\"},620]]"}},"nsMap":{},"nsPrev":{},"id":654,"ts":1714755914.382,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":1,"idx":616},{"idx":631,"type":"child","at":2},{"idx":634,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":1,"idx":616},{"idx":631,"type":"child","at":2},{"idx":634,"type":"end"}]}],"prev":{"631":{"type":"list","values":[632,633,634],"loc":631},"634":{"type":"string","first":643,"templates":[],"loc":634},"643":{"type":"stringText","loc":643,"text":"[[\\\"+\\\", (value), 641]]"}},"meta":{},"metaPrev":{},"map":{"631":{"type":"list","values":[632,633,634],"loc":631},"634":{"type":"blank","loc":634},"643":null},"nsMap":{},"nsPrev":{},"id":655,"ts":1714755924.745,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":1,"idx":616},{"idx":631,"type":"child","at":2},{"idx":1041,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":1,"idx":616},{"idx":631,"type":"child","at":2},{"idx":634,"type":"start"}]}],"prev":{"631":{"type":"list","values":[632,633,634],"loc":631},"1041":null},"meta":{},"metaPrev":{},"map":{"631":{"type":"list","values":[632,633,1041],"loc":631},"1041":{"type":"raw-code","lang":"javascript","loc":1041,"raw":"[[\"+\",{\"type\":\"value\"},641]]"}},"nsMap":{},"nsPrev":{},"id":656,"ts":1714755925.549,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":2,"idx":616},{"idx":646,"type":"child","at":2},{"idx":649,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":2,"idx":616},{"idx":646,"type":"child","at":2},{"idx":649,"type":"end"}]}],"prev":{"646":{"type":"list","values":[647,648,649],"loc":646},"649":{"type":"string","first":874,"templates":[],"loc":649},"874":{"type":"stringText","loc":874,"text":"[[\\\"x\\\", (value), 653]]"}},"meta":{},"metaPrev":{},"map":{"646":{"type":"list","values":[647,648,649],"loc":646},"649":{"type":"blank","loc":649},"874":null},"nsMap":{},"nsPrev":{},"id":657,"ts":1714755926.745,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":2,"idx":616},{"idx":646,"type":"child","at":2},{"idx":1042,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":2,"idx":616},{"idx":646,"type":"child","at":2},{"idx":649,"type":"subtext","at":0}]}],"prev":{"646":{"type":"list","values":[647,648,649],"loc":646},"1042":null},"meta":{},"metaPrev":{},"map":{"646":{"type":"list","values":[647,648,1042],"loc":646},"1042":{"type":"raw-code","lang":"javascript","loc":1042,"raw":"[[\"x\",{\"type\":\"value\"},653]]"}},"nsMap":{},"nsPrev":{},"id":658,"ts":1714755929.866,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":3,"idx":616},{"idx":656,"type":"child","at":2},{"idx":659,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":3,"idx":616},{"idx":656,"type":"child","at":2},{"idx":659,"type":"end"}]}],"prev":{"656":{"type":"list","values":[657,658,659],"loc":656},"659":{"type":"string","first":672,"templates":[],"loc":659},"672":{"type":"stringText","loc":672,"text":"[[\\\"m\\\", (value), 663], [\\\"+\\\", (value), 665]]"}},"meta":{},"metaPrev":{},"map":{"656":{"type":"list","values":[657,658,659],"loc":656},"659":{"type":"blank","loc":659},"672":null},"nsMap":{},"nsPrev":{},"id":659,"ts":1714755931.204,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":3,"idx":616},{"idx":656,"type":"child","at":2},{"idx":1043,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":3,"idx":616},{"idx":656,"type":"child","at":2},{"idx":659,"type":"subtext","at":0}]}],"prev":{"656":{"type":"list","values":[657,658,659],"loc":656},"1043":null},"meta":{},"metaPrev":{},"map":{"656":{"type":"list","values":[657,658,1043],"loc":656},"1043":{"type":"raw-code","lang":"javascript","loc":1043,"raw":"[[\"m\",{\"type\":\"value\"},663],[\"+\",{\"type\":\"value\"},665]]"}},"nsMap":{},"nsPrev":{},"id":660,"ts":1714755933.082,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":4,"idx":616},{"idx":673,"type":"child","at":2},{"idx":676,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":4,"idx":616},{"idx":673,"type":"child","at":2},{"idx":676,"type":"end"}]}],"prev":{"673":{"type":"list","values":[674,675,676],"loc":673},"676":{"type":"string","first":688,"templates":[],"loc":676},"688":{"type":"stringText","loc":688,"text":"[[\\\"+\\\", (value), 686]]"}},"meta":{},"metaPrev":{},"map":{"673":{"type":"list","values":[674,675,676],"loc":673},"676":{"type":"blank","loc":676},"688":null},"nsMap":{},"nsPrev":{},"id":661,"ts":1714755934.408,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":4,"idx":616},{"idx":673,"type":"child","at":2},{"idx":1044,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":4,"idx":616},{"idx":673,"type":"child","at":2},{"idx":676,"type":"subtext","at":0}]}],"prev":{"673":{"type":"list","values":[674,675,676],"loc":673},"1044":null},"meta":{},"metaPrev":{},"map":{"673":{"type":"list","values":[674,675,1044],"loc":673},"1044":{"type":"raw-code","lang":"javascript","loc":1044,"raw":"[[\"+\",{\"type\":\"value\"},686]]"}},"nsMap":{},"nsPrev":{},"id":662,"ts":1714755935.786,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":5,"idx":616},{"idx":814,"type":"child","at":2},{"idx":817,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":5,"idx":616},{"idx":814,"type":"child","at":2},{"idx":817,"type":"end"}]}],"prev":{"814":{"type":"list","values":[815,816,817],"loc":814},"817":{"type":"string","first":875,"templates":[],"loc":817},"875":{"type":"stringText","loc":875,"text":"[[\\\"compile-pat\\\", (value), 855], [\\\"+\\\", (value), 868]]"}},"meta":{},"metaPrev":{},"map":{"814":{"type":"list","values":[815,816,817],"loc":814},"817":{"type":"blank","loc":817},"875":null},"nsMap":{},"nsPrev":{},"id":663,"ts":1714755936.73,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":5,"idx":616},{"idx":814,"type":"child","at":2},{"idx":1045,"type":"end"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":598,"idx":0},{"type":"ns","child":602,"idx":598},{"type":"ns-top","idx":602},{"idx":601,"type":"child","at":2},{"type":"child","at":5,"idx":616},{"idx":814,"type":"child","at":2},{"idx":817,"type":"subtext","at":0}]}],"prev":{"814":{"type":"list","values":[815,816,817],"loc":814},"1045":null},"meta":{},"metaPrev":{},"map":{"814":{"type":"list","values":[815,816,1045],"loc":814},"1045":{"type":"raw-code","lang":"javascript","loc":1045,"raw":"[[\"compile-pat\",{\"type\":\"value\"},855],[\"+\",{\"type\":\"value\"},868]]"}},"nsMap":{},"nsPrev":{},"id":664,"ts":1714755938.62,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns-top","idx":876},{"idx":877,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns-top","idx":876},{"idx":877,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":false}},"nsPrev":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":true}},"id":665,"ts":1714756075.205,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns-top","idx":878},{"idx":879,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns-top","idx":878},{"idx":879,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"878":{"type":"normal","id":878,"top":879,"children":[]}},"nsPrev":{"878":{"type":"normal","id":878,"top":879,"children":[]}},"id":666,"ts":1714756080.783,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns-top","idx":878},{"idx":879,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns-top","idx":878},{"idx":879,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"878":{"type":"normal","id":878,"top":879,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"878":{"type":"normal","id":878,"top":879,"children":[]}},"id":667,"ts":1714756083.223,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"892":{"type":"normal","id":892,"top":893,"children":[]}},"id":668,"ts":1714756085.902,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null},"collapsed":true}},"nsPrev":{"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null}}},"id":669,"ts":1714756089.682,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null},"collapsed":false}},"nsPrev":{"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null},"collapsed":true}},"id":670,"ts":1714756090.298,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns","idx":878},{"type":"ns-top","idx":892},{"type":"start","idx":893}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"876":{"type":"normal","id":876,"top":877,"children":[878,924,934,955,969],"collapsed":false},"878":{"type":"normal","id":878,"top":879,"children":[892],"display":{"id":"none","options":null}}},"nsPrev":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":false},"878":{"type":"normal","id":878,"top":879,"children":[],"display":{"id":"none","options":null}}},"id":671,"ts":1714756093.667,"libraryRoot":""},{"id":672,"meta":{},"metaPrev":{},"revert":671,"prev":{},"map":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":892,"idx":876},{"type":"ns-top","idx":892},{"idx":893,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":878,"idx":876},{"type":"ns","idx":878},{"type":"ns-top","idx":892},{"type":"start","idx":893}]}],"nsMap":{"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":false},"878":{"type":"normal","id":878,"top":879,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"876":{"type":"normal","id":876,"top":877,"children":[878,924,934,955,969],"collapsed":false},"878":{"type":"normal","id":878,"top":879,"children":[892],"display":{"id":"none","options":null}}},"ts":1714756094.38,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"214":{"type":"normal","top":213,"children":[26,28,30,99,293,112,58,71,138,150],"id":214,"collapsed":true}},"nsPrev":{"214":{"type":"normal","top":213,"children":[26,28,30,99,293,112,58,71,138,150],"id":214,"collapsed":false}},"id":673,"ts":1714757327.448,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":924,"idx":876},{"type":"ns-top","idx":924},{"idx":925,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":924,"idx":876},{"type":"ns-top","idx":924},{"idx":925,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"924":{"type":"normal","id":924,"top":925,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"924":{"type":"normal","id":924,"top":925,"children":[]}},"id":674,"ts":1714757329.999,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":934,"idx":876},{"type":"ns-top","idx":934},{"idx":935,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":934,"idx":876},{"type":"ns-top","idx":934},{"idx":935,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"934":{"type":"normal","id":934,"top":935,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"934":{"type":"normal","id":934,"top":935,"children":[]}},"id":675,"ts":1714757331.969,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":955,"idx":876},{"type":"ns-top","idx":955},{"idx":956,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":955,"idx":876},{"type":"ns-top","idx":955},{"idx":956,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"955":{"type":"normal","id":955,"top":956,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"955":{"type":"normal","id":955,"top":956,"children":[]}},"id":676,"ts":1714757334.183,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":969,"idx":876},{"type":"ns-top","idx":969},{"idx":970,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":876,"idx":0},{"type":"ns","child":969,"idx":876},{"type":"ns-top","idx":969},{"idx":970,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"969":{"type":"normal","id":969,"top":970,"children":[],"display":{"id":"none","options":null}}},"nsPrev":{"969":{"type":"normal","id":969,"top":970,"children":[]}},"id":677,"ts":1714757336.434,"libraryRoot":""},{"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"prevAt":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"prev":{},"meta":{},"metaPrev":{},"map":{},"nsMap":{"214":{"type":"normal","top":213,"children":[26,28,30,99,293,112,58,71,138,150],"id":214,"collapsed":false}},"nsPrev":{"214":{"type":"normal","top":213,"children":[26,28,30,99,293,112,58,71,138,150],"id":214,"collapsed":true}},"id":678,"ts":1714757444.083,"libraryRoot":""}],"clipboard":[],"hover":[],"regs":{},"at":[{"start":[{"type":"card","idx":-1,"card":0},{"type":"ns","child":214,"idx":0},{"type":"ns-top","idx":214},{"idx":213,"type":"start"}]}],"cards":[{"path":[],"top":0}],"nsMap":{"0":{"id":0,"top":-1,"children":[1,3,214,876,212,36,598,9,575],"type":"normal"},"1":{"id":1,"top":0,"children":[],"type":"normal"},"3":{"type":"normal","top":2,"children":[],"id":3},"9":{"type":"normal","top":8,"children":[594,755,596,571,573,739],"id":9,"plugin":{"id":"evaluator","options":"bootstrap.js"},"collapsed":false},"22":{"type":"normal","top":21,"children":[],"id":22},"24":{"type":"normal","top":23,"children":[],"id":24},"26":{"type":"normal","top":25,"children":[],"id":26},"28":{"type":"normal","top":27,"children":[],"id":28},"30":{"type":"normal","top":29,"children":[],"id":30},"32":{"type":"normal","top":31,"children":[],"id":32},"34":{"type":"normal","top":33,"children":[],"id":34},"36":{"type":"normal","top":35,"children":[421,423,22,287,276,873,370,336,456],"id":36,"collapsed":false},"43":{"type":"normal","top":42,"children":[],"id":43},"47":{"type":"normal","top":46,"children":[],"id":47},"51":{"type":"normal","top":50,"children":[],"id":51},"58":{"type":"normal","top":57,"children":[],"id":58},"62":{"type":"normal","top":61,"children":[],"id":62},"69":{"type":"normal","top":68,"children":[],"id":69},"71":{"type":"normal","top":70,"children":[],"id":71},"77":{"type":"normal","top":76,"children":[],"id":77},"79":{"type":"normal","top":78,"children":[],"id":79,"plugin":{"id":"fixture","options":null}},"99":{"type":"normal","top":98,"children":[110],"id":99,"collapsed":true},"110":{"type":"normal","top":109,"children":[],"id":110},"112":{"type":"normal","top":111,"children":[],"id":112},"114":{"type":"normal","top":113,"children":[],"id":114},"138":{"type":"normal","top":137,"children":[],"id":138},"141":{"type":"normal","top":140,"children":[],"id":141},"150":{"type":"normal","top":149,"children":[],"id":150},"189":{"type":"normal","top":188,"children":[],"id":189},"212":{"type":"normal","top":211,"children":[43,998,1023,216,218,220],"id":212,"collapsed":false},"214":{"type":"normal","top":213,"children":[26,28,30,99,293,112,58,71,138,150],"id":214,"collapsed":false},"216":{"type":"normal","top":215,"children":[34,69,24,802,32,797,141,62,47,51,114,79],"id":216,"collapsed":false},"218":{"type":"normal","top":217,"id":218,"children":[189,77,776],"collapsed":false},"220":{"type":"normal","top":219,"children":[222,226,228,248,230],"id":220,"collapsed":false},"222":{"type":"normal","top":221,"children":[],"id":222},"226":{"type":"normal","top":225,"children":[],"id":226},"228":{"type":"normal","top":227,"children":[],"id":228},"230":{"type":"normal","top":229,"children":[],"id":230,"plugin":{"id":"fixture","options":null}},"248":{"type":"normal","top":249,"children":[],"id":248},"276":{"type":"normal","top":275,"children":[],"id":276},"287":{"type":"normal","top":286,"children":[],"id":287},"293":{"type":"normal","top":292,"children":[],"id":293},"336":{"type":"normal","top":335,"children":[],"id":336},"370":{"type":"normal","top":369,"children":[],"id":370,"plugin":{"id":"fixture","options":null}},"421":{"type":"normal","top":420,"id":421,"children":[]},"423":{"type":"normal","top":422,"children":[],"id":423},"456":{"type":"normal","top":455,"children":[],"id":456,"plugin":{"id":"fixture","options":null}},"571":{"type":"normal","top":570,"children":[],"id":571},"573":{"type":"normal","top":572,"children":[],"id":573},"575":{"type":"normal","top":576,"children":[],"id":575},"594":{"type":"normal","top":593,"children":[],"id":594},"596":{"type":"normal","top":595,"children":[],"id":596},"598":{"type":"normal","top":597,"id":598,"children":[600,690,612,614,608,602,692,694],"collapsed":false},"600":{"type":"normal","top":599,"children":[],"id":600},"602":{"type":"normal","top":601,"children":[],"id":602,"plugin":{"id":"fixture","options":null}},"608":{"type":"normal","top":607,"children":[],"id":608},"612":{"type":"normal","top":611,"children":[],"id":612},"614":{"type":"normal","top":613,"children":[],"id":614},"690":{"type":"normal","top":689,"children":[],"id":690},"692":{"type":"normal","top":691,"children":[],"id":692},"694":{"type":"normal","top":693,"children":[],"id":694,"plugin":{"id":"fixture","options":null}},"739":{"type":"normal","top":738,"children":[741],"id":739},"741":{"type":"normal","top":740,"children":[],"id":741},"755":{"type":"normal","top":754,"children":[809,811,813,807],"id":755,"collapsed":true},"776":{"type":"normal","top":775,"children":[],"id":776},"797":{"type":"normal","top":796,"children":[],"id":797},"802":{"type":"normal","id":802,"top":803,"children":[]},"807":{"type":"normal","top":806,"children":[],"id":807},"809":{"type":"normal","top":808,"children":[],"id":809},"811":{"type":"normal","top":810,"children":[],"id":811},"813":{"type":"normal","top":812,"children":[],"id":813},"873":{"type":"normal","top":872,"children":[],"id":873},"876":{"type":"normal","id":876,"top":877,"children":[878,892,924,934,955,969],"collapsed":false},"878":{"type":"normal","id":878,"top":879,"children":[],"display":{"id":"none","options":null}},"892":{"type":"normal","id":892,"top":893,"children":[],"display":{"id":"none","options":null},"collapsed":false},"924":{"type":"normal","id":924,"top":925,"children":[],"display":{"id":"none","options":null}},"934":{"type":"normal","id":934,"top":935,"children":[],"display":{"id":"none","options":null}},"955":{"type":"normal","id":955,"top":956,"children":[],"display":{"id":"none","options":null}},"969":{"type":"normal","id":969,"top":970,"children":[],"display":{"id":"none","options":null}},"998":{"type":"normal","top":997,"children":[],"id":998},"1023":{"type":"normal","top":1022,"children":[],"id":1023}},"highlight":[],"evaluator":":js:"}